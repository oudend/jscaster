import { EmbeddedActionsParser, IRecognitionException, IRuleConfig, IToken, TokenType } from "chevrotain";
import { ArraySpecifier, CaseBlock, CaseLabel, CompoundStatement, Declaration, Expression, ExpressionStatement, FullySpecifiedType, FunctionCall, InitDeclaratorListDeclaration, IterationStatement, JumpStatement, LayoutQualifier, Node, ParameterDeclaration, PpCall, PpDefine, PpDir, PpExtension, PpInclude, PpNode, PpPragma, SelectionStatement, Statement, StorageQualifier, StructDeclaration, StructSpecifier, SwitchStatement, Token, TranslationUnit, TypeQualifier, TypeQualifierDeclaration, TypeSpecifier, UniformBlock } from "./nodes";
declare class GLSLParser extends EmbeddedActionsParser {
    multiplicativeExpression: () => Expression;
    additiveExpression: () => Expression;
    shiftExpression: () => Expression;
    relationalExpression: () => Expression;
    equalityExpression: () => Expression;
    andExpression: () => Expression;
    exclusiveOrExpression: () => Expression;
    inclusiveOrExpression: () => Expression;
    logicalAndExpression: () => Expression;
    logicalXorExpression: () => Expression;
    logicalOrExpression: () => Expression;
    assignmentExpression: () => Expression;
    expression: () => Expression;
    conditionalExpression: () => Expression;
    switchStatement: () => SwitchStatement;
    caseBlock: () => CaseBlock;
    jumpStatement: () => JumpStatement;
    primaryExpression: () => Expression;
    constantExpression: () => Expression;
    layoutQualifier: () => LayoutQualifier;
    storageQualifier: () => StorageQualifier;
    typeQualifier: () => TypeQualifier;
    precisionQualifier: () => IToken;
    arraySpecifier: () => ArraySpecifier;
    typeSpecifierNonArray: () => IToken | StructSpecifier;
    typeSpecifierNoPrec: () => TypeSpecifier;
    functionCall: () => FunctionCall;
    functionCallHeader: import("chevrotain").ParserMethod<[], void>;
    postfixExpression: () => Expression;
    unaryExpression: () => Expression;
    ppUnaryExpression: () => Expression;
    ppPrimaryExpression: () => Expression;
    ppConstantExpression: () => Expression;
    typeSpecifier: () => TypeSpecifier;
    parameterDeclaration: () => ParameterDeclaration;
    fullySpecifiedType: () => FullySpecifiedType;
    structDeclaration: () => StructDeclaration;
    structSpecifier: () => StructSpecifier;
    initializer: () => Expression;
    singleDeclaration: import("chevrotain").ParserMethod<[], void>;
    initDeclaratorList: () => InitDeclaratorListDeclaration;
    expressionStatement: () => ExpressionStatement;
    condition: () => Expression | InitDeclaratorListDeclaration;
    caseLabel: () => CaseLabel;
    selectionStatement: () => SelectionStatement;
    statement: (newScope?: boolean) => Statement;
    compoundStatement: (newScope?: boolean) => CompoundStatement;
    iterationStatement: () => IterationStatement;
    translationUnit: () => TranslationUnit;
    uniformBlock: () => UniformBlock;
    protected uniformBlockHeader: import("chevrotain").ParserMethod<[], void>;
    typeQualifierDeclaration: () => TypeQualifierDeclaration;
    externalDeclaration: (uniformBlock?: boolean, function_?: boolean) => Declaration;
    ppDefine: () => PpDefine;
    ppInclude: () => PpInclude;
    ppCall: () => PpCall;
    ppCallArg: import("chevrotain").ParserMethod<[], Token[]>;
    ppNone: () => PpNode;
    ppMulti: () => PpNode;
    ppPragma: () => PpPragma;
    ppSingle: () => PpNode;
    ppExtension: () => PpExtension;
    ppDirective: () => PpNode;
    ppIdentifier: () => Token;
    protected getTokensOnLine(): Token[];
    protected backtracking: boolean;
    ppDefs: (PpDefine | PpDir)[];
    private preprocessing;
    constructor();
    reset(): void;
    protected LEFT_ASSOC(rule: (idx: number) => Expression, tok: TokenType): Expression;
    protected ANNOTATE<T extends Node | IToken>(implementation: (...implArgs: any[]) => T): (...implArgs: any[]) => T;
    protected BACKTRACK<T>(grammarRule: (...args: any[]) => T, args?: any[]): () => boolean;
    protected RR<F extends (...args: any[]) => any>(name: string, implementation: F, config?: IRuleConfig<ReturnType<F>>): F;
    protected FINALIZE(n: Node, firstToken: IToken): void;
    isAtEof(): boolean;
}
export declare const GLSL_PARSER: GLSLParser;
export declare function checkParsingErrors(input: string, errors: IRecognitionException[]): void;
export declare function shortDesc(node: Node | IToken): string;
export declare function shortDesc2(node: Node | IToken): string;
export declare function parseInput(originalInput: string): TranslationUnit;
export {};
//# sourceMappingURL=parser.d.ts.map