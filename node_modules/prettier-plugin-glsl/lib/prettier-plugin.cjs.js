'use strict';

var prettier = require('prettier');
var doc = require('prettier/doc');
var lodash = require('lodash');
var chevrotain = require('chevrotain');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var doc__namespace = /*#__PURE__*/_interopNamespaceDefault(doc);

function getTokenStartLine(token) {
    return token.lineNoCont !== undefined ? token.lineNoCont : token.startLine;
}
function isExpression(n) {
    return [
        "arrayAccess",
        "assignmentExpression",
        "binaryExpression",
        "commaExpression",
        "conditionalExpression",
        "constantExpression",
        "fieldAccess",
        "functionCall",
        "methodCall",
        "postfixExpression",
        "unaryExpression",
        "variableExpression",
    ].includes(n.kind);
}
class AbstractVisitor {
    visit(n) {
        return n && this[n.kind](n);
    }
    arraySpecifier(n) {
        this.visit(n.size);
        return;
    }
    binaryExpression(n) {
        this.visit(n.lhs);
        this.visit(n.rhs);
        return;
    }
    methodCall(n) {
        this.visit(n.on);
        this.visit(n.functionCall);
        return;
    }
    functionCall(n) {
        this.visit(n.callee);
        for (const a of n.args) {
            this.visit(a);
        }
        return;
    }
    arrayAccess(n) {
        this.visit(n.on);
        this.visit(n.index);
        return;
    }
    translationUnit(n) {
        for (const d of n.declarations) {
            this.visit(d);
        }
        return;
    }
    assignmentExpression(n) {
        this.visit(n.lhs);
        this.visit(n.rhs);
        return;
    }
    fieldAccess(n) {
        this.visit(n.on);
        return;
    }
    conditionalExpression(n) {
        this.visit(n.condition);
        this.visit(n.yes);
        this.visit(n.no);
        return;
    }
    postfixExpression(n) {
        this.visit(n.on);
        return;
    }
    commaExpression(n) {
        this.visit(n.lhs);
        this.visit(n.rhs);
        return;
    }
    unaryExpression(n) {
        this.visit(n.on);
        return;
    }
    functionDefinition(n) {
        this.visit(n.returnType);
        for (const p of n.params) {
            this.visit(p);
        }
        this.visit(n.body);
        return;
    }
    functionPrototype(n) {
        this.visit(n.returnType);
        for (const p of n.params) {
            this.visit(p);
        }
        return;
    }
    parameterDeclaration(n) {
        this.visit(n.arraySpecifier);
        this.visit(n.typeSpecifier);
        return;
    }
    typeSpecifier(n) {
        if (isNode(n.typeSpecifierNonArray)) {
            this.visit(n.typeSpecifierNonArray);
        }
        this.visit(n.arraySpecifier);
        return;
    }
    compoundStatement(n) {
        for (const n1 of n.statements) {
            this.visit(n1);
        }
        return;
    }
    returnStatement(n) {
        this.visit(n.what);
        return;
    }
    continueStatement(_n) {
        return;
    }
    breakStatement(_n) {
        return;
    }
    discardStatement(_n) {
        return;
    }
    declarator(n) {
        this.visit(n.arraySpecifier);
        this.visit(n.init);
        return;
    }
    doWhileStatement(n) {
        this.visit(n.statement);
        this.visit(n.conditionExpression);
        return;
    }
    whileStatement(n) {
        this.visit(n.conditionExpression);
        this.visit(n.statement);
        return;
    }
    forStatement(n) {
        this.visit(n.initExpression);
        this.visit(n.conditionExpression);
        this.visit(n.loopExpression);
        this.visit(n.statement);
        return;
    }
    expressionStatement(n) {
        this.visit(n.expression);
        return;
    }
    initDeclaratorListDeclaration(n) {
        this.visit(n.fsType);
        for (const d of n.declarators) {
            this.visit(d);
        }
        return;
    }
    precisionDeclaration(n) {
        this.visit(n.typeSpecifierNoPrec);
        return;
    }
    selectionStatement(n) {
        this.visit(n.condition);
        this.visit(n.yes);
        this.visit(n.no);
        return;
    }
    storageQualifier(_n) {
        return;
    }
    switchStatement(n) {
        this.visit(n.initExpression);
        for (const c of n.cases) {
            this.visit(c);
        }
        return;
    }
    caseLabel(n) {
        this.visit(n.case_);
        return;
    }
    caseBlock(n) {
        this.visit(n.caseLabel);
        for (const s of n.statements) {
            this.visit(s);
        }
        return;
    }
    fullySpecifiedType(n) {
        this.visit(n.typeQualifier);
        this.visit(n.typeSpecifier);
        return;
    }
    typeQualifier(n) {
        this.visit(n.storageQualifier);
        this.visit(n.layoutQualifier);
        return;
    }
    structSpecifier(n) {
        for (const d of n.declarations) {
            this.visit(d);
        }
        return;
    }
    layoutQualifier(_n) {
        return;
    }
    invariantDeclaration(_n) {
        return;
    }
    structDeclaration(n) {
        this.visit(n.fsType);
        for (const d of n.declarators) {
            this.visit(d);
        }
        return;
    }
    variableExpression(_n) {
        return;
    }
    constantExpression(_n) {
        return;
    }
    uniformBlock(n) {
        this.visit(n.typeQualifier);
        for (const d of n.declarations) {
            this.visit(d);
        }
        this.visit(n.arraySpecifier);
        return;
    }
    ppDefine(n) {
        this.visit(n.node);
        return;
    }
    ppDir(_n) {
        return;
    }
    ppExtension(_n) {
        return;
    }
    ppCall(_n) {
        return;
    }
    ppPragma(_n) {
        return;
    }
}
function isToken(x) {
    return "tokenType" in x;
}
function isNode(x) {
    return "kind" in x;
}

const DEV = process.env.NODE_ENV !== "production";
function underline(str, start, end) {
    return str + "\n" + "-".repeat(start) + "^".repeat(end - start);
}
function substrContext(input, token) {
    const lines = input.split("\n");
    const sLine = token.startLine;
    const eLine = token.endLine;
    return ("./src/compiler.lambda:" +
        sLine +
        ":" +
        (token.startColumn - 1) +
        "\n" +
        lines
            .map((l, i) => [i + 1, l])
            .slice(sLine - 2, eLine + 2)
            .map(([n, l]) => {
            if (n >= sLine && n <= eLine) {
                l = underline(l, 6 + (sLine === n ? token.startColumn - 1 : 0), 6 + (eLine === n ? token.endColumn : l.length));
            }
            return ("" + n).padStart(5) + " " + l;
        })
            .join("\n"));
    // start -= 20
    // if (start < 0) {
    //   start = 0
    // } else {
    //   start = input.lastIndexOf("\n", start) + 1
    // }
    // end += 20
    // if (end > input.length) {
    //   end = input.length
    // } else {
    //   end = input.indexOf("\n", end)
    // }
    // return input.substr(start, end)
}

// noinspection JSUnusedGlobalSymbols
const RESERVED_KEYWORDS = [
    "active",
    "asm",
    "atomic_uint",
    "attribute",
    "cast",
    "class",
    "coherent",
    "common",
    "double",
    "dvec2",
    "dvec3",
    "dvec4",
    "enum",
    "extern",
    "external",
    "filter",
    "fixed",
    "fvec2",
    "fvec3",
    "fvec4",
    "goto",
    "half",
    "hvec2",
    "hvec3",
    "hvec4",
    "iimage1D",
    "iimage1DArray",
    "iimage2D",
    "iimage2DArray",
    "iimage3D",
    "iimageBuffer",
    "iimageCube",
    "image1D",
    "image1DArray",
    "image2D",
    "image2DArray",
    "image3D",
    "imageBuffer",
    "imageCube",
    "inline",
    "input",
    "interface",
    "isampler1D",
    "isampler1DArray",
    "isampler2DMS",
    "isampler2DMSArray",
    "isampler2DRect",
    "isamplerBuffer",
    "long",
    "namespace",
    "noinline",
    "noperspective",
    "output",
    "partition",
    "patch",
    "public",
    "readonly",
    "resource",
    "restrict",
    "sample",
    "sampler1D",
    "sampler1DArray",
    "sampler1DArrayShadow",
    "sampler1DShadow",
    "sampler2DMS",
    "sampler2DMSArray",
    "sampler2DRect",
    "sampler2DRectShadow",
    "sampler3DRect",
    "samplerBuffer",
    "short",
    "sizeof",
    "static",
    "subroutine",
    "superp",
    "template",
    "this",
    "typedef",
    "uimage1D",
    "uimage1DArray",
    "uimage2D",
    "uimage2DArray",
    "uimage3D",
    "uimageBuffer",
    "uimageCube",
    "union",
    "unsigned",
    "usampler1D",
    "usampler1DArray",
    "usampler2DMS",
    "usampler2DMSArray",
    "usampler2DRect",
    "usamplerBuffer",
    "using",
    "volatile",
    "volatile",
    "writeonly",
];
var TOKEN;
(function (TOKEN) {
    // Categories
    TOKEN.ASSIGN_OP = chevrotain.createToken({ name: "ASSIGN_OP", pattern: chevrotain.Lexer.NA });
    TOKEN.UNARY_OP = chevrotain.createToken({ name: "UNARY_OP", pattern: chevrotain.Lexer.NA });
    TOKEN.POSTFIX_OP = chevrotain.createToken({
        name: "POSTFIX_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.PRECISION_QUALIFIER = chevrotain.createToken({
        name: "PRECISION_QUALIFIER",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.INTERPOLATION_QUALIFIER = chevrotain.createToken({
        name: "INTERPOLATION_QUALIFIER",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.MULTIPLICATIVE_OP = chevrotain.createToken({
        name: "MULTIPLICATIVE_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.ADDITIVE_OP = chevrotain.createToken({
        name: "ADDITIVE_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.SHIFT_OP = chevrotain.createToken({
        name: "SHIFT_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.RELATIONAL_OP = chevrotain.createToken({
        name: "RELATIONAL_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.EQUALITY_OP = chevrotain.createToken({
        name: "EQUALITY_OP",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.PARAMETER_QUALIFIER = chevrotain.createToken({
        name: "PARAMETER_QUALIFIER",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.WHITESPACE = chevrotain.createToken({
        name: "WHITESPACE",
        pattern: /\s+/,
        group: chevrotain.Lexer.SKIPPED,
    });
    TOKEN.LINE_COMMENT = chevrotain.createToken({
        name: "LINE_COMMENT",
        pattern: /\/\/[^\r\n]*/,
        group: "COMMENTS",
    });
    TOKEN.MULTILINE_COMMENT = chevrotain.createToken({
        name: "MULTILINE_COMMENT",
        pattern: /\/\*[\s\S]*?\*\//,
        group: "COMMENTS",
    });
    // ASSIGNMENT OPERATORS
    TOKEN.MULASSIGN = chevrotain.createToken({
        name: "MULASSIGN",
        pattern: "*=",
        label: "'*='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.DIVASSIGN = chevrotain.createToken({
        name: "DIVASSIGN",
        pattern: "/=",
        label: "'/='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.MODASSIGN = chevrotain.createToken({
        name: "MODASSIGN",
        pattern: "%=",
        label: "'%='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.ADDASSIGN = chevrotain.createToken({
        name: "ADDASSIGN",
        pattern: "+=",
        label: "'+='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.SUBASSIGN = chevrotain.createToken({
        name: "SUBASSIGN",
        pattern: "-=",
        label: "'-='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.LEFTASSIGN = chevrotain.createToken({
        name: "LEFTASSIGN",
        pattern: "<<=",
        label: "'<<='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.RIGHTASSIGN = chevrotain.createToken({
        name: "RIGHTASSIGN",
        pattern: ">>=",
        label: "'>>='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.ANDASSIGN = chevrotain.createToken({
        name: "ANDASSIGN",
        pattern: "&=",
        label: "'&='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.XORASSIGN = chevrotain.createToken({
        name: "XORASSIGN",
        pattern: "^=",
        label: "'^='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.ORASSIGN = chevrotain.createToken({
        name: "ORASSIGN",
        pattern: "|=",
        label: "'|='",
        categories: TOKEN.ASSIGN_OP,
    });
    // OPERATORS
    TOKEN.INC_OP = chevrotain.createToken({
        name: "INC_OP",
        pattern: "++",
        label: "'++'",
        categories: [TOKEN.UNARY_OP, TOKEN.POSTFIX_OP],
    });
    TOKEN.QUESTION = chevrotain.createToken({
        name: "QUESTION",
        pattern: "?",
        label: "'?'",
    });
    TOKEN.COLON = chevrotain.createToken({
        name: "COLON",
        pattern: ":",
        label: "':'",
    });
    TOKEN.DEC_OP = chevrotain.createToken({
        name: "DEC_OP",
        pattern: "--",
        label: "'--'",
        categories: [TOKEN.UNARY_OP, TOKEN.POSTFIX_OP],
    });
    TOKEN.AND_OP = chevrotain.createToken({
        name: "AND_OP",
        pattern: "&&",
        label: "'&&'",
    });
    TOKEN.XOR_OP = chevrotain.createToken({
        name: "XOR_OP",
        pattern: "^^",
        label: "'^^'",
    });
    TOKEN.OR_OP = chevrotain.createToken({
        name: "OR_OP",
        pattern: "||",
        label: "'||'",
    });
    TOKEN.LEFT_OP = chevrotain.createToken({
        name: "LEFT_OP",
        pattern: "<<",
        label: "'<<'",
        categories: TOKEN.SHIFT_OP,
    });
    TOKEN.RIGHT_OP = chevrotain.createToken({
        name: "RIGHT_OP",
        pattern: ">>",
        label: "'>>'",
        categories: TOKEN.SHIFT_OP,
    });
    TOKEN.EQ_OP = chevrotain.createToken({
        name: "EQ_OP",
        pattern: "==",
        label: "'=='",
        categories: TOKEN.EQUALITY_OP,
    });
    TOKEN.NE_OP = chevrotain.createToken({
        name: "NE_OP",
        pattern: "!=",
        label: "'!='",
        categories: TOKEN.EQUALITY_OP,
    });
    TOKEN.LE_OP = chevrotain.createToken({
        name: "LE_OP",
        pattern: "<=",
        label: "'<='",
        categories: TOKEN.RELATIONAL_OP,
    });
    TOKEN.GE_OP = chevrotain.createToken({
        name: "GE_OP",
        pattern: ">=",
        label: "'>='",
        categories: TOKEN.RELATIONAL_OP,
    });
    TOKEN.LEFT_ANGLE = chevrotain.createToken({
        name: "LEFT_ANGLE",
        pattern: "<",
        label: "'<'",
        categories: TOKEN.RELATIONAL_OP,
    });
    TOKEN.RIGHT_ANGLE = chevrotain.createToken({
        name: "RIGHT_ANGLE",
        pattern: ">",
        label: "'>'",
        categories: TOKEN.RELATIONAL_OP,
    });
    TOKEN.PLUS = chevrotain.createToken({
        name: "PLUS",
        pattern: "+",
        label: "'+'",
        categories: [TOKEN.UNARY_OP, TOKEN.ADDITIVE_OP],
    });
    TOKEN.TILDE = chevrotain.createToken({
        name: "TILDE",
        pattern: "~",
        label: "'~'",
        categories: TOKEN.UNARY_OP,
    });
    TOKEN.BANG = chevrotain.createToken({
        name: "BANG",
        pattern: "!",
        label: "'!'",
        categories: TOKEN.UNARY_OP,
    });
    TOKEN.CARET = chevrotain.createToken({
        name: "CARET",
        pattern: "^",
        label: "'^'",
    });
    TOKEN.AMPERSAND = chevrotain.createToken({
        name: "AND",
        pattern: "&",
        label: "'&'",
    });
    TOKEN.VERTICAL_BAR = chevrotain.createToken({
        name: "VERTICAL_BAR",
        pattern: "|",
        label: "'|'",
    });
    TOKEN.SLASH = chevrotain.createToken({
        name: "SLASH",
        pattern: "/",
        label: "'/'",
        categories: TOKEN.MULTIPLICATIVE_OP,
    });
    TOKEN.PERCENT = chevrotain.createToken({
        name: "PERCENT",
        pattern: "%",
        label: "'%'",
        categories: TOKEN.MULTIPLICATIVE_OP,
    });
    TOKEN.STAR = chevrotain.createToken({
        name: "STAR",
        pattern: "*",
        label: "'*'",
        categories: TOKEN.MULTIPLICATIVE_OP,
    });
    TOKEN.DASH = chevrotain.createToken({
        name: "DASH",
        pattern: "-",
        label: "'-'",
        categories: [TOKEN.UNARY_OP, TOKEN.ADDITIVE_OP],
    });
    TOKEN.COMMA = chevrotain.createToken({
        name: "COMMA",
        pattern: ",",
        label: "','",
    });
    TOKEN.EQUAL = chevrotain.createToken({
        name: "EQUAL",
        pattern: "=",
        label: "'='",
        categories: TOKEN.ASSIGN_OP,
    });
    TOKEN.LEFT_PAREN = chevrotain.createToken({
        name: "LEFT_PAREN",
        pattern: "(",
        label: "'('",
    });
    TOKEN.RIGHT_PAREN = chevrotain.createToken({
        name: "RIGHT_PAREN",
        pattern: ")",
        label: "')'",
    });
    TOKEN.LEFT_BRACKET = chevrotain.createToken({
        name: "LEFT_BRACKET",
        pattern: "[",
        label: "'['",
    });
    TOKEN.RIGHT_BRACKET = chevrotain.createToken({
        name: "RIGHT_BRACKET",
        pattern: "]",
        label: "']'",
    });
    TOKEN.LEFT_BRACE = chevrotain.createToken({
        name: "LEFT_BRACE",
        pattern: "{",
        label: "'{'",
    });
    TOKEN.RIGHT_BRACE = chevrotain.createToken({
        name: "RIGHT_BRACE",
        pattern: "}",
        label: "'}'",
    });
    TOKEN.SEMICOLON = chevrotain.createToken({
        name: "SEMICOLON",
        pattern: ";",
        label: "';'",
    });
    // Category which includes the preprocessor directive tokens such as define,
    // if etc...
    // To avoid this category, an alternative solution might be to manually
    // convert the preprocessor directive tokens to identifier tokens if they are
    // not part of a preprocessor directive as part of the preprocessing phase.
    TOKEN.IDENTIFIER = chevrotain.createToken({
        name: "IDENTIFIER",
        pattern: chevrotain.Lexer.NA,
    });
    TOKEN.NON_PP_IDENTIFIER = chevrotain.createToken({
        name: "NON_PP_IDENTIFIER",
        pattern: /\w[\w\d]*/i,
        categories: TOKEN.IDENTIFIER,
    });
    TOKEN.PP = chevrotain.createToken({
        name: "PP",
        pattern: chevrotain.Lexer.NA,
        categories: TOKEN.IDENTIFIER,
    });
    const createPP = (name, pattern) => chevrotain.createToken({
        name,
        pattern,
        categories: TOKEN.PP,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
    });
    TOKEN.DEFINE = createPP("DEFINE", "define");
    TOKEN.UNDEF = createPP("UNDEF", "undef");
    TOKEN.ENDIF = createPP("ENDIF", "endif");
    TOKEN.IFDEF = createPP("IFDEF", "ifdef");
    TOKEN.IFNDEF = createPP("IFNDEF", "ifndef");
    TOKEN.ELIF = createPP("ELIF", "elif");
    TOKEN.ERROR = createPP("ERROR", "error");
    TOKEN.VERSION = createPP("VERSION", "version");
    TOKEN.PRAGMA_DIRECTIVE = chevrotain.createToken({
        name: "PRAGMA_DIRECTIVE",
        pattern: /#\s*pragma\s+[^\r\n]*/,
    });
    TOKEN.LINE = createPP("LINE", "line");
    TOKEN.EXTENSION = createPP("EXTENSION", "extension");
    TOKEN.INCLUDE = createPP("INCLUDE", "include");
    TOKEN.HASH = chevrotain.createToken({ name: "HASH", pattern: "#" });
    TOKEN.KEYWORD = chevrotain.createToken({ name: "KEYWORD", pattern: chevrotain.Lexer.NA });
    const createKeyword = (const1, category) => chevrotain.createToken({
        name: const1,
        pattern: const1.toLowerCase(),
        label: "'" + const1.toLowerCase() + "'",
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: category ? [TOKEN.KEYWORD, category] : TOKEN.KEYWORD,
    });
    TOKEN.CONST = createKeyword("CONST");
    TOKEN.UNIFORM = createKeyword("UNIFORM");
    TOKEN.LAYOUT = createKeyword("LAYOUT");
    TOKEN.CENTROID = createKeyword("CENTROID");
    TOKEN.FLAT = createKeyword("FLAT", TOKEN.INTERPOLATION_QUALIFIER);
    TOKEN.SMOOTH = createKeyword("SMOOTH", TOKEN.INTERPOLATION_QUALIFIER);
    TOKEN.BREAK = createKeyword("BREAK");
    TOKEN.CONTINUE = createKeyword("CONTINUE");
    TOKEN.DO = createKeyword("DO");
    TOKEN.PRECISION = createKeyword("PRECISION");
    TOKEN.FOR = createKeyword("FOR");
    TOKEN.WHILE = createKeyword("WHILE");
    TOKEN.SWITCH = createKeyword("SWITCH");
    TOKEN.CASE = createKeyword("CASE");
    TOKEN.DEFAULT = createKeyword("DEFAULT");
    TOKEN.IF = createKeyword("IF");
    TOKEN.ELSE = createKeyword("ELSE");
    TOKEN.INVARIANT = createKeyword("INVARIANT");
    TOKEN.INOUT = createKeyword("INOUT", TOKEN.PARAMETER_QUALIFIER);
    TOKEN.OUT = createKeyword("OUT", TOKEN.PARAMETER_QUALIFIER);
    TOKEN.VOID = createKeyword("VOID");
    TOKEN.STRUCT = createKeyword("STRUCT");
    TOKEN.DISCARD = createKeyword("DISCARD");
    TOKEN.RETURN = createKeyword("RETURN");
    TOKEN.LOWP = createKeyword("LOWP", TOKEN.PRECISION_QUALIFIER);
    TOKEN.MEDIUMP = createKeyword("MEDIUMP", TOKEN.PRECISION_QUALIFIER);
    TOKEN.HIGHP = createKeyword("HIGHP", TOKEN.PRECISION_QUALIFIER);
    TOKEN.CONSTANT = chevrotain.createToken({ name: "CONSTANT", pattern: chevrotain.Lexer.NA });
    TOKEN.BASIC_TYPE = chevrotain.createToken({
        name: "BASIC_TYPE",
        pattern: chevrotain.Lexer.NA,
    });
    const createBasicType = (t) => chevrotain.createToken({
        name: t.toUpperCase(),
        pattern: t,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: TOKEN.BASIC_TYPE,
    });
    TOKEN.BOOL = createBasicType("bool");
    TOKEN.INT = createBasicType("int");
    TOKEN.FLOAT = createBasicType("float");
    TOKEN.MAT2X3 = createBasicType("mat2x3");
    TOKEN.MAT2X4 = createBasicType("mat2x4");
    TOKEN.MAT2X2 = chevrotain.createToken({
        name: "mat2x2".toUpperCase(),
        pattern: /mat2(?:x2)?/,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: TOKEN.BASIC_TYPE,
        label: "mat2",
    });
    TOKEN.MAT3X2 = createBasicType("mat3x2");
    TOKEN.MAT3X4 = createBasicType("mat3x4");
    TOKEN.MAT3X3 = chevrotain.createToken({
        name: "mat3x3".toUpperCase(),
        pattern: /mat3(?:x3)?/,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: TOKEN.BASIC_TYPE,
        label: "mat3",
    });
    TOKEN.MAT4X2 = createBasicType("mat4x2");
    TOKEN.MAT4X3 = createBasicType("mat4x3");
    TOKEN.MAT4X4 = chevrotain.createToken({
        name: "MAT4X4",
        pattern: /mat4(?:x4)?/,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: TOKEN.BASIC_TYPE,
        label: "mat4",
    });
    TOKEN.VEC2 = createBasicType("vec2");
    TOKEN.VEC3 = createBasicType("vec3");
    TOKEN.VEC4 = createBasicType("vec4");
    TOKEN.IVEC2 = createBasicType("ivec2");
    TOKEN.IVEC3 = createBasicType("ivec3");
    TOKEN.IVEC4 = createBasicType("ivec4");
    TOKEN.BVEC2 = createBasicType("bvec2");
    TOKEN.BVEC3 = createBasicType("bvec3");
    TOKEN.BVEC4 = createBasicType("bvec4");
    TOKEN.UINT = createBasicType("uint");
    TOKEN.UVEC2 = createBasicType("uvec2");
    TOKEN.UVEC3 = createBasicType("uvec3");
    TOKEN.UVEC4 = createBasicType("uvec4");
    TOKEN.USAMPLERCUBE = createBasicType("usamplerCube");
    TOKEN.USAMPLER3D = createBasicType("usampler3D");
    TOKEN.USAMPLER2DARRAY = createBasicType("usampler2DArray");
    TOKEN.USAMPLER2D = createBasicType("usampler2D");
    TOKEN.SAMPLERCUBESHADOW = createBasicType("samplerCubeShadow");
    TOKEN.SAMPLERCUBE = createBasicType("samplerCube");
    TOKEN.SAMPLER3D = createBasicType("sampler3D");
    TOKEN.SAMPLER2DSHADOW = createBasicType("sampler2DShadow");
    TOKEN.SAMPLER2DARRAYSHADOW = createBasicType("sampler2DArrayShadow");
    TOKEN.SAMPLER2DARRAY = createBasicType("sampler2DArray");
    TOKEN.SAMPLER2D = createBasicType("sampler2D");
    TOKEN.ISAMPLERCUBE = createBasicType("isamplerCube");
    TOKEN.ISAMPLER3D = createBasicType("isampler3D");
    TOKEN.ISAMPLER2DARRAY = createBasicType("isampler2DArray");
    TOKEN.ISAMPLER2D = createBasicType("isampler2D");
    TOKEN.IN = createKeyword("IN", TOKEN.PARAMETER_QUALIFIER);
    TOKEN.VARYING = createKeyword("VARYING");
    TOKEN.ATTRIBUTE = createKeyword("ATTRIBUTE");
    TOKEN.BOOLCONSTANT = chevrotain.createToken({
        name: "BOOLCONSTANT",
        pattern: /true|false/,
        longer_alt: TOKEN.NON_PP_IDENTIFIER,
        categories: TOKEN.CONSTANT,
    });
    TOKEN.FLOATCONSTANT = chevrotain.createToken({
        name: "FLOATCONSTANT",
        pattern: /((\d+\.\d*|\.\d+)(e[+-]?\d+)?|\d+e[+-]?\d+)f?/i,
        categories: TOKEN.CONSTANT,
    });
    TOKEN.DOT = chevrotain.createToken({
        name: "DOT",
        pattern: ".",
        label: "'.'",
    });
    TOKEN.UINTCONSTANT = chevrotain.createToken({
        name: "UINTCONSTANT",
        pattern: /0x[\da-f]+u|\d+u/i,
        categories: TOKEN.CONSTANT,
    });
    TOKEN.INTCONSTANT = chevrotain.createToken({
        name: "INTCONSTANT",
        pattern: /0x[\da-f]+|\d+/i,
        categories: TOKEN.CONSTANT,
    });
    // Only used in the context of #include.
    TOKEN.STRING = chevrotain.createToken({
        name: "STRING",
        pattern: /"([^"\\]+|\\")+"/,
    });
})(TOKEN || (TOKEN = {}));
// IDENTIFIER needs to go last, but must be declared first
// so it can be referenced in longerAlt
const ALL_TOKENS = lodash.pull(Object.values(TOKEN), TOKEN.NON_PP_IDENTIFIER).flatMap((x) => (Array.isArray(x) ? x : [x]));
ALL_TOKENS.push(TOKEN.NON_PP_IDENTIFIER);
const GLSL_LEXER = new chevrotain.Lexer(ALL_TOKENS, { ensureOptimizations: DEV });
function checkLexingErrors(input, lexingResult) {
    if (lexingResult.errors.length) {
        throw new Error("LEXER ERROR: " +
            lexingResult.errors
                .map((e) => e.message +
                ":\n" +
                substrContext(input, {
                    startLine: e.line,
                    startColumn: e.column,
                    endLine: e.line,
                    endColumn: e.column + e.length,
                }))
                // .map((e) => e.message)
                .join());
    }
}
function doOp(op, a, b) {
    switch (op) {
        case TOKEN.PLUS:
            return a + b;
        case TOKEN.DASH:
            return a - b;
        case TOKEN.STAR:
            return a * b;
        case TOKEN.PERCENT:
            return a % b;
        case TOKEN.SLASH:
            return a / b;
        case TOKEN.LEFT_OP:
            return a << b;
        case TOKEN.RIGHT_OP:
            return a >> b;
        case TOKEN.EQ_OP:
            return a === b;
        case TOKEN.NE_OP:
            return a !== b;
        case TOKEN.LE_OP:
            return a <= b;
        case TOKEN.GE_OP:
            return a >= b;
        case TOKEN.LEFT_ANGLE:
            return a < b;
        case TOKEN.RIGHT_ANGLE:
            return a > b;
        case TOKEN.XOR_OP:
            return a !== b;
        case TOKEN.AND_OP:
            return a && b;
        case TOKEN.OR_OP:
            return a || b;
        case TOKEN.AMPERSAND:
            return a & b;
        case TOKEN.CARET:
            return a ^ b;
        case TOKEN.VERTICAL_BAR:
            return a | b;
        default:
            throw new Error();
    }
}
function isBitwiseOperator(tokenType) {
    return (tokenType === TOKEN.CARET ||
        tokenType === TOKEN.VERTICAL_BAR ||
        tokenType === TOKEN.AMPERSAND);
}

new (class extends AbstractVisitor {
    constructor() {
        super(...arguments);
        this.markError = lodash.noop;
    }
    eval(n, isDefined, markError) {
        this.isDefined = isDefined;
        this.markError = markError;
        return super.visit(n);
    }
    constantExpression(n) {
        if (n.const_.tokenType !== TOKEN.INTCONSTANT) {
            throw new Error("XX");
        }
        return +n.const_.image;
    }
    unaryExpression(n) {
        switch (n.op.tokenType) {
            case TOKEN.NON_PP_IDENTIFIER:
                // must be "defined"
                return +this.isDefined(n.on.var.image);
            case TOKEN.DASH:
                return -this.visit(n.on);
            case TOKEN.TILDE:
                return ~this.visit(n.on);
            case TOKEN.BANG:
                return +!this.visit(n.on);
            case TOKEN.PLUS:
                return this.visit(n.on);
            default:
                throw new Error(n.op.tokenType.name);
        }
    }
    binaryExpression(n) {
        const l = this.visit(n.lhs);
        switch (n.op.tokenType) {
            case TOKEN.AND_OP:
                return l && this.visit(n.rhs);
            case TOKEN.OR_OP:
                return l || this.visit(n.rhs);
            default: {
                const r = this.visit(n.rhs);
                return doOp(n.op.tokenType, l, r) | 0;
            }
        }
    }
    variableExpression(_n) {
        // We have already preprocessed the ppConstantExpression at this point.
        // If there are any "variables" left, it means they were not defined. This
        // is not valid in GLSL ES 3.0, so we output an error.
        this.markError("P0001", _n.var, "undefined identifier " + _n.var.image);
        return 0;
    }
})();
function charsToStartOfLine(input, offset) {
    let i = offset;
    while (i >= 0 && input[i] !== "\r" && input[i] !== "\n") {
        i--;
    }
    return offset - i - 1;
}
function applyLineContinuations(input) {
    const changes = [];
    let newlines = "";
    let newlinesCount = 0;
    let columnDiff = 0;
    const result = input.replace(/\\(\r\n|\n\r|\r|\n)(.*?)(?:(?=\\?[\r\n])|$)/g, (substring, nl, nonWhitespace, offset) => {
        newlinesCount++;
        columnDiff += charsToStartOfLine(input, offset);
        changes.push({
            originalOffset: offset + 1 + nl.length,
            newOffset: offset - newlines.length,
            length: nonWhitespace.length,
            lineDiff: -newlinesCount,
            columnDiff,
        });
        newlines += " " + nl; // space to replace \
        let resultNewlines = "";
        if (!(input.length > offset + substring.length &&
            input[offset + substring.length] === "\\")) {
            resultNewlines = newlines;
            newlines = "";
            newlinesCount = 0;
            columnDiff = 0;
        }
        return nonWhitespace + resultNewlines;
    });
    return { result, changes };
}
function fixLocations(tokens, changes) {
    let tokensIdx = 0;
    function fixLocation(token, change) {
        const offsetDiff = change.originalOffset - change.newOffset;
        if (token.startOffset >= change.newOffset) {
            token.lineNoCont = token.startLine;
            token.startOffset += offsetDiff;
            token.startLine -= change.lineDiff;
            token.startColumn -= change.columnDiff;
        }
        token.endOffset += offsetDiff;
        token.endLine -= change.lineDiff;
        token.endColumn -= change.columnDiff;
    }
    for (const change of changes) {
        // skip tokens before this change
        while (tokens[tokensIdx] &&
            tokens[tokensIdx].endOffset < change.newOffset) {
            tokensIdx++;
        }
        // fix location on all tokens inside this location
        while (tokens[tokensIdx] &&
            tokens[tokensIdx].startOffset < change.newOffset + change.length) {
            fixLocation(tokens[tokensIdx], change);
            tokensIdx++;
        }
    }
}

/* eslint-disable @typescript-eslint/member-ordering */
// NB: There are actually some ambiguities which this parser can't resolve, e.g.
// "i;" in a function could either be an expressionStatement containing a
// variableExpression or an initDeclaratorList of type "struct i" with no
// declarations. As neither of these is a useful construct, we always parse
// ambiguous declarations/statements as TODO.
class GLSLParser extends chevrotain.EmbeddedActionsParser {
    getTokensOnLine() {
        const tokens = [];
        const line = getTokenStartLine(this.LA(0));
        let tok;
        while (getTokenStartLine((tok = this.LA(1))) === line) {
            tokens.push(tok);
            this.SKIP_TOKEN();
        }
        return tokens;
    }
    constructor() {
        super(ALL_TOKENS, { skipValidations: !DEV });
        //SPEC variable_identifier:
        //SPEC     IDENTIFIER
        //SPEC primary_expression:
        //SPEC     variable_identifier
        //SPEC     INTCONSTANT
        //SPEC     UINTCONSTANT
        //SPEC     FLOATCONSTANT
        //SPEC     BOOLCONSTANT
        //SPEC     LEFT_PAREN expression RIGHT_PAREN
        //SPEC postfix_expression:
        //SPEC     primary_expression
        //SPEC     postfix_expression LEFT_BRACKET integer_expression RIGHT_BRACKET
        //SPEC     function_call
        //SPEC     postfix_expression DOT FIELD_SELECTION
        //SPEC     postfix_expression INC_OP
        //SPEC     postfix_expression DEC_OP
        //SPEC integer_expression:
        //SPEC     expression
        //SPEC function_call:
        //SPEC     function_call_or_method
        //SPEC function_call_or_method:
        //SPEC     function_call_generic
        //SPEC     postfix_expression DOT function_call_generic
        //SPEC function_call_generic:
        //SPEC     function_call_header_with_parameters RIGHT_PAREN
        //SPEC     function_call_header_no_parameters RIGHT_PAREN
        //SPEC function_call_header_no_parameters:
        //SPEC     function_call_header VOID
        //SPEC     function_call_header
        //SPEC function_call_header_with_parameters:
        //SPEC     function_call_header assignment_expression
        //SPEC     function_call_header_with_parameters COMMA assignment_expression
        //SPEC function_call_header:
        //SPEC     function_identifier LEFT_PAREN
        //SPEC // Grammar Note: Constructors look like functions, but lexical analysis recognized most of them as
        //SPEC     // keywords. They are now recognized through “type_specifier”.
        //SPEC     // Methods (.length) and identifiers are recognized through postfix_expression.
        //SPEC function_identifier:
        //SPEC     type_specifier
        //SPEC     IDENTIFIER
        //SPEC     FIELD_SELECTION
        //SPEC unary_expression:
        //SPEC     postfix_expression
        //SPEC     INC_OP unary_expression
        //SPEC     DEC_OP unary_expression
        //SPEC     multiplicative_expression PERCENT unary_expression
        this.multiplicativeExpression = this.RR("multiplicativeExpression", () => this.LEFT_ASSOC(
        // this.unaryExpression,
        this.preprocessing ? this.ppUnaryExpression : this.unaryExpression, TOKEN.MULTIPLICATIVE_OP));
        //SPEC // Grammar Note: No traditional style type casts.
        //SPEC unary_operator:
        //SPEC     PLUS
        //SPEC     DASH
        //SPEC     BANG
        //SPEC     TILDE
        //SPEC // Grammar Note: No '*' or '&' unary ops. Pointers are not supported.
        //SPEC multiplicative_expression:
        //SPEC     unary_expression
        //SPEC     multiplicative_expression STAR unary_expression
        //SPEC     multiplicative_expression SLASH unary_expression
        //SPEC     additive_expression DASH multiplicative_expression
        this.additiveExpression = this.RR("additiveExpression", () => this.LEFT_ASSOC(this.multiplicativeExpression, TOKEN.ADDITIVE_OP));
        //SPEC additive_expression:
        //SPEC     multiplicative_expression
        //SPEC     additive_expression PLUS multiplicative_expression
        //SPEC     shift_expression RIGHT_OP additive_expression
        this.shiftExpression = this.RR("shiftExpression", () => this.LEFT_ASSOC(this.additiveExpression, TOKEN.SHIFT_OP));
        //SPEC shift_expression:
        //SPEC     additive_expression
        //SPEC     shift_expression LEFT_OP additive_expression
        //SPEC     relational_expression GE_OP shift_expression
        this.relationalExpression = this.RR("relationalExpression", () => this.LEFT_ASSOC(this.shiftExpression, TOKEN.RELATIONAL_OP));
        //SPEC relational_expression:
        //SPEC     shift_expression
        //SPEC     relational_expression LEFT_ANGLE shift_expression
        //SPEC     relational_expression RIGHT_ANGLE shift_expression
        //SPEC     relational_expression LE_OP shift_expression
        //SPEC     equality_expression NE_OP relational_expression
        this.equalityExpression = this.RR("equalityExpression", () => this.LEFT_ASSOC(this.relationalExpression, TOKEN.EQUALITY_OP));
        //SPEC equality_expression:
        //SPEC     relational_expression
        //SPEC     equality_expression EQ_OP relational_expression
        //SPEC     and_expression AMPERSAND equality_expression
        this.andExpression = this.RR("andExpression", () => this.LEFT_ASSOC(this.equalityExpression, TOKEN.AMPERSAND));
        //SPEC and_expression:
        //SPEC     equality_expression
        //SPEC     exclusive_or_expression CARET and_expression
        this.exclusiveOrExpression = this.RR("exclusiveOrExpression", () => this.LEFT_ASSOC(this.andExpression, TOKEN.CARET));
        //SPEC exclusive_or_expression:
        //SPEC     and_expression
        //SPEC     inclusive_or_expression VERTICAL_BAR exclusive_or_expression
        this.inclusiveOrExpression = this.RR("inclusiveOrExpression", () => this.LEFT_ASSOC(this.exclusiveOrExpression, TOKEN.VERTICAL_BAR));
        //SPEC inclusive_or_expression:
        //SPEC     exclusive_or_expression
        //SPEC     logical_and_expression AND_OP inclusive_or_expression
        this.logicalAndExpression = this.RR("logicalAndExpression", () => this.LEFT_ASSOC(this.inclusiveOrExpression, TOKEN.AND_OP));
        //SPEC logical_and_expression:
        //SPEC     inclusive_or_expression
        //SPEC     logical_xor_expression XOR_OP logical_and_expression
        this.logicalXorExpression = this.RR("logicalXorExpression", () => this.LEFT_ASSOC(this.logicalAndExpression, TOKEN.XOR_OP));
        //SPEC logical_xor_expression:
        //SPEC     logical_and_expression
        //SPEC     logical_or_expression OR_OP logical_xor_expression
        this.logicalOrExpression = this.RR("logicalOrExpression", () => this.LEFT_ASSOC(this.logicalXorExpression, TOKEN.OR_OP));
        //SPEC logical_or_expression:
        //SPEC     logical_xor_expression
        //SPEC     OR_ASSIGN
        this.assignmentExpression = this.RR("assignmentExpression", () => {
            // unary expression on lhs leads to ambiguities when parsing
            // (conditionalExpression starts with unaryExpression), instead use
            // assignmentExpression: conditionalExpression (assignmentOperator conditionalExpression)*
            // and do semantic check later.
            // right-associative
            const result = this.SUBRULE(this.conditionalExpression);
            return (this.OPTION(() => {
                const op = this.CONSUME(TOKEN.ASSIGN_OP);
                const rhs = this.SUBRULE1(this.assignmentExpression);
                return { kind: "assignmentExpression", lhs: result, op, rhs };
            }) ?? result);
        });
        //SPEC conditional_expression:
        //SPEC     logical_or_expression
        this.expression = this.RR("expression", () => {
            let result;
            this.AT_LEAST_ONE_SEP({
                SEP: TOKEN.COMMA,
                DEF: () => {
                    const rhs = this.SUBRULE(this.assignmentExpression);
                    return (result = !result
                        ? rhs
                        : { kind: "commaExpression", lhs: result, rhs });
                },
            });
            return result;
        });
        //SPEC assignment_expression:
        //SPEC     conditional_expression
        //SPEC     unary_expression assignment_operator assignment_expression
        //SPEC assignment_operator:
        //SPEC     EQUAL
        //SPEC     MUL_ASSIGN
        //SPEC     DIV_ASSIGN
        //SPEC     MOD_ASSIGN
        //SPEC     ADD_ASSIGN
        //SPEC     SUB_ASSIGN
        //SPEC     LEFT_ASSIGN
        //SPEC     RIGHT_ASSIGN
        //SPEC     AND_ASSIGN
        //SPEC     XOR_ASSIGN
        //SPEC     logical_or_expression QUESTION expression COLON assignment_expression
        this.conditionalExpression = this.RR("conditionalExpression", () => {
            const result = this.SUBRULE1(this.logicalOrExpression);
            return (this.OPTION(() => ({
                kind: "conditionalExpression",
                condition: result,
                QUESTION: this.CONSUME(TOKEN.QUESTION),
                yes: this.SUBRULE2(this.expression),
                COLON: this.CONSUME(TOKEN.COLON),
                no: this.SUBRULE3(this.assignmentExpression),
            })) ?? result);
        });
        //SPEC expression:
        //SPEC     assignment_expression
        //SPEC     expression COMMA assignment_expression
        //SPEC constant_expression:
        //SPEC     conditional_expression
        //SPEC declaration:
        //SPEC     function_prototype SEMICOLON
        //SPEC     init_declarator_list SEMICOLON
        //SPEC     PRECISION precision_qualifier type_specifier_no_prec SEMICOLON
        //SPEC     type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE SEMICOLON
        //SPEC     type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE
        //SPEC     IDENTIFIER SEMICOLON
        //SPEC     type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE
        //SPEC     IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET SEMICOLON
        //SPEC     type_qualifier SEMICOLON
        //SPEC function_prototype:
        //SPEC     function_declarator RIGHT_PAREN
        //SPEC function_declarator:
        //SPEC     function_header
        //SPEC     function_header_with_parameters
        //SPEC function_header_with_parameters:
        //SPEC     function_header parameter_declaration
        //SPEC     function_header_with_parameters COMMA parameter_declaration
        //SPEC function_header:
        //SPEC     fully_specified_type IDENTIFIER LEFT_PAREN
        //SPEC parameter_declarator:
        //SPEC     type_specifier IDENTIFIER
        //SPEC     type_specifier IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET
        //SPEC parameter_declaration:
        //SPEC     parameter_type_qualifier parameter_qualifier parameter_declarator
        //SPEC     parameter_qualifier parameter_declarator
        //SPEC     parameter_type_qualifier parameter_qualifier parameter_type_specifier
        //SPEC     parameter_qualifier parameter_type_specifier
        //SPEC parameter_qualifier:
        //SPEC     /* empty */
        //SPEC     IN
        //SPEC     OUT
        //SPEC     INOUT
        //SPEC parameter_type_specifier:
        //SPEC     statement_list
        // public switchStatement = this.RR("switchStatement", (): SwitchStatement => {
        //   this.CONSUME(TOKEN.SWITCH)
        //   this.CONSUME(TOKEN.LEFT_PAREN)
        //   const initExpression = this.SUBRULE(this.expression)
        //   this.CONSUME(TOKEN.RIGHT_PAREN)
        //   const body = this.SUBRULE(this.compoundStatement, { ARGS: [true] })
        //   return { kind: "switchStatement", initExpression, body }
        // })
        this.switchStatement = this.RR("switchStatement", () => {
            this.CONSUME(TOKEN.SWITCH);
            this.CONSUME(TOKEN.LEFT_PAREN);
            const initExpression = this.SUBRULE(this.expression);
            this.CONSUME(TOKEN.RIGHT_PAREN);
            this.CONSUME(TOKEN.LEFT_BRACE);
            const cases = [];
            this.MANY(() => cases.push(this.SUBRULE(this.caseBlock)));
            this.CONSUME(TOKEN.RIGHT_BRACE);
            return { kind: "switchStatement", initExpression, cases };
        });
        this.caseBlock = this.RR("caseBlock", () => {
            const caseLabel = this.SUBRULE(this.caseLabel);
            const statements = [];
            this.MANY1(() => statements.push(this.SUBRULE(this.statement)));
            return { kind: "caseBlock", caseLabel, statements };
        });
        //SPEC init_declarator_list:
        //SPEC     single_declaration
        //SPEC     init_declarator_list COMMA IDENTIFIER
        //SPEC     init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression
        //SPEC     RIGHT_BRACKET
        //SPEC     init_declarator_list COMMA IDENTIFIER LEFT_BRACKET
        //SPEC     RIGHT_BRACKET EQUAL initializer
        //SPEC     init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression
        //SPEC     RIGHT_BRACKET EQUAL initializer
        //SPEC     init_declarator_list COMMA IDENTIFIER EQUAL initializer
        //SPEC single_declaration:
        //SPEC     fully_specified_type
        //SPEC     fully_specified_type IDENTIFIER
        //SPEC     fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET
        //SPEC     fully_specified_type IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL initializer
        //SPEC     fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression
        //SPEC     RIGHT_BRACKET EQUAL initializer
        //SPEC     fully_specified_type IDENTIFIER EQUAL initializer
        //SPEC     INVARIANT IDENTIFIER
        //SPEC // Grammar Note: No 'enum', or 'typedef'.
        //SPEC fully_specified_type:
        //SPEC     type_specifier
        //SPEC     type_qualifier type_specifier
        //SPEC invariant_qualifier:
        //SPEC     INVARIANT
        //SPEC interpolation_qualifier:
        //SPEC     SMOOTH
        //SPEC     FLAT
        //SPEC layout_qualifier:
        //SPEC     LAYOUT LEFT_PAREN layout_qualifier_id_list RIGHT_PAREN
        //SPEC layout_qualifier_id_list:
        //SPEC     layout_qualifier_id
        //SPEC     layout_qualifier_id_list COMMA layout_qualifier_id
        //SPEC layout_qualifier_id:
        //SPEC     IDENTIFIER
        //SPEC     IDENTIFIER EQUAL INTCONSTANT
        //SPEC     IDENTIFIER EQUAL UINTCONSTANT
        //SPEC parameter_type_qualifier:
        //SPEC     CONST
        //SPEC type_qualifier:
        //SPEC     storage_qualifier
        //SPEC     layout_qualifier
        //SPEC     layout_qualifier storage_qualifier
        //SPEC     interpolation_qualifier storage_qualifier
        //SPEC     interpolation_qualifier
        //SPEC     invariant_qualifier storage_qualifier
        //SPEC // Grammar Note: No 'goto'. Gotos are not supported.
        this.jumpStatement = this.RR("jumpStatement", () => {
            const result = this.OR([
                {
                    ALT: () => {
                        this.CONSUME(TOKEN.CONTINUE);
                        return { kind: "continueStatement" };
                    },
                },
                {
                    ALT: () => {
                        this.CONSUME(TOKEN.BREAK);
                        return { kind: "breakStatement" };
                    },
                },
                {
                    ALT: () => {
                        this.CONSUME(TOKEN.DISCARD);
                        return { kind: "discardStatement" };
                    },
                },
                {
                    ALT: () => {
                        this.CONSUME(TOKEN.RETURN);
                        const what = this.OPTION(() => this.SUBRULE(this.expression));
                        return { kind: "returnStatement", what };
                    },
                },
            ]);
            this.CONSUME(TOKEN.SEMICOLON);
            return result;
        });
        //SPEC storage_qualifier:
        //SPEC     CONST
        //SPEC     IN
        //SPEC     OUT
        //SPEC     CENTROID IN
        //SPEC     CENTROID OUT
        //SPEC     UNIFORM
        //SPEC type_specifier:
        //SPEC     type_specifier_no_prec
        //SPEC     precision_qualifier type_specifier_no_prec
        //SPEC type_specifier_no_prec:
        //SPEC     type_specifier_nonarray
        //SPEC     type_specifier_nonarray LEFT_BRACKET RIGHT_BRACKET
        this.primaryExpression = this.RR("primaryExpression", () => this.OR([
            {
                ALT: () => {
                    this.CONSUME(TOKEN.LEFT_PAREN);
                    const result = this.SUBRULE(this.expression);
                    this.CONSUME(TOKEN.RIGHT_PAREN);
                    return result;
                },
            },
            {
                ALT: () => ({
                    kind: "variableExpression",
                    var: this.CONSUME(TOKEN.IDENTIFIER),
                }),
            },
            {
                ALT: () => ({
                    kind: "constantExpression",
                    const_: this.CONSUME(TOKEN.CONSTANT),
                }),
            },
        ]));
        //SPEC type_specifier_nonarray:
        //SPEC     VOID
        //SPEC     FLOAT
        //SPEC     INT
        //SPEC     UINT
        //SPEC     BOOL
        //SPEC     VEC2
        //SPEC     VEC3
        //SPEC     VEC4
        //SPEC     BVEC2
        //SPEC     BVEC3
        //SPEC     BVEC4
        //SPEC     IVEC2
        //SPEC     IVEC3
        //SPEC     IVEC4
        //SPEC     UVEC2
        //SPEC     UVEC3
        //SPEC     UVEC4
        //SPEC     MAT2
        //SPEC     MAT3
        //SPEC     MAT4
        //SPEC     MAT2X2
        //SPEC     MAT2X3
        //SPEC     MAT2X4
        //SPEC     MAT3X2
        //SPEC     MAT3X3
        //SPEC     MAT3X4
        //SPEC     MAT4X2
        //SPEC     MAT4X3
        //SPEC     MAT4X4
        //SPEC     SAMPLER2D
        //SPEC     SAMPLER3D
        //SPEC     SAMPLERCUBE
        //SPEC     SAMPLER2DSHADOW
        //SPEC     SAMPLERCUBESHADOW
        //SPEC     SAMPLER2DARRAY
        //SPEC     SAMPLER2DARRAYSHADOW
        //SPEC     ISAMPLER2D
        //SPEC     ISAMPLER3D
        //SPEC     ISAMPLERCUBE
        //SPEC     ISAMPLER2DARRAY
        //SPEC     USAMPLER2D
        //SPEC     USAMPLER3D
        //SPEC     USAMPLERCUBE
        //SPEC     USAMPLER2DARRAY
        //SPEC     struct_specifier
        //SPEC     TYPE_NAME
        //SPEC precision_qualifier:
        //SPEC     HIGH_PRECISION
        //SPEC     MEDIUM_PRECISION
        //SPEC     LOW_PRECISION
        //SPEC struct_specifier:
        //SPEC     STRUCT IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE
        //SPEC     STRUCT LEFT_BRACE struct_declaration_list RIGHT_BRACE
        //SPEC struct_declaration_list:
        //SPEC     struct_declaration
        //SPEC     struct_declaration_list struct_declaration
        //SPEC struct_declaration:
        //SPEC     type_specifier struct_declarator_list SEMICOLON
        //SPEC     type_qualifier type_specifier struct_declarator_list SEMICOLON
        //SPEC struct_declarator_list:
        //SPEC     struct_declarator
        //SPEC     struct_declarator_list COMMA struct_declarator
        //SPEC struct_declarator:
        //SPEC     IDENTIFIER
        //SPEC     IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
        //SPEC     IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET
        //SPEC initializer:
        //SPEC     assignment_expression
        //SPEC declaration_statement:
        //SPEC     declaration
        //SPEC statement:
        //SPEC     compound_statement_with_scope
        //SPEC     simple_statement
        //SPEC statement_no_new_scope:
        //SPEC     compound_statement_no_new_scope
        //SPEC     simple_statement
        //SPEC statement_with_scope:
        //SPEC     compound_statement_no_new_scope
        //SPEC     simple_statement
        //SPEC // Grammar Note: labeled statements for SWITCH only; 'goto' is not supported.
        //SPEC simple_statement:
        //SPEC     declaration_statement
        //SPEC     expression_statement
        //SPEC     selection_statement
        //SPEC     switch_statement
        //SPEC     case_label
        //SPEC     iteration_statement
        //SPEC     jump_statement
        //SPEC compound_statement_with_scope:
        //SPEC     LEFT_BRACE RIGHT_BRACE
        //SPEC     LEFT_BRACE statement_list RIGHT_BRACE
        //SPEC compound_statement_no_new_scope:
        //SPEC     LEFT_BRACE RIGHT_BRACE
        //SPEC     LEFT_BRACE statement_list RIGHT_BRACE
        this.constantExpression = this.RR("constantExpression", () => this.SUBRULE(this.conditionalExpression));
        //SPEC statement_list:
        //SPEC     statement
        //SPEC     statement_list statement
        //SPEC expression_statement:
        //SPEC     SEMICOLON
        //SPEC     expression SEMICOLON
        //SPEC selection_statement:
        //SPEC     IF LEFT_PAREN expression RIGHT_PAREN selection_rest_statement
        //SPEC selection_rest_statement:
        //SPEC     statement_with_scope ELSE statement_with_scope
        //SPEC     statement_with_scope
        //SPEC condition:
        //SPEC     expression
        //SPEC     fully_specified_type IDENTIFIER EQUAL initializer
        //SPEC switch_statement:
        //SPEC     SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_BRACE switch_statement_list
        //SPEC     RIGHT_BRACE
        //SPEC switch_statement_list:
        //SPEC     /* nothing */
        this.layoutQualifier = this.RR("layoutQualifier", () => {
            this.CONSUME(TOKEN.LAYOUT);
            this.CONSUME(TOKEN.LEFT_PAREN);
            const layoutQualifierIds = [];
            this.AT_LEAST_ONE_SEP({
                SEP: TOKEN.COMMA,
                DEF: () => {
                    const IDENTIFIER = this.CONSUME(TOKEN.IDENTIFIER);
                    let init;
                    this.OPTION(() => {
                        this.CONSUME(TOKEN.EQUAL);
                        init = this.OR([
                            { ALT: () => this.CONSUME(TOKEN.INTCONSTANT) },
                            { ALT: () => this.CONSUME(TOKEN.UINTCONSTANT) },
                        ]);
                    });
                    layoutQualifierIds.push({ IDENTIFIER, init });
                },
            });
            this.CONSUME(TOKEN.RIGHT_PAREN);
            return { kind: "layoutQualifier", layoutQualifierIds };
        });
        //SPEC case_label:
        //SPEC     CASE expression COLON
        //SPEC     DEFAULT COLON
        //SPEC iteration_statement:
        //SPEC     WHILE LEFT_PAREN condition RIGHT_PAREN statement_no_new_scope
        //SPEC     DO statement_with_scope WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
        this.storageQualifier = this.RR("storageQualifier", () => {
            let CONST, CENTROID, IN, OUT, UNIFORM, VARYING, ATTRIBUTE;
            this.OR([
                { ALT: () => (CONST = this.CONSUME(TOKEN.CONST)) },
                {
                    ALT: () => {
                        CENTROID = this.OPTION(() => this.CONSUME(TOKEN.CENTROID));
                        this.OR9([
                            { ALT: () => (IN = this.CONSUME(TOKEN.IN)) },
                            { ALT: () => (OUT = this.CONSUME(TOKEN.OUT)) },
                            { ALT: () => (VARYING = this.CONSUME(TOKEN.VARYING)) },
                            { ALT: () => (ATTRIBUTE = this.CONSUME(TOKEN.ATTRIBUTE)) },
                        ]);
                    },
                },
                { ALT: () => (UNIFORM = this.CONSUME(TOKEN.UNIFORM)) },
            ]);
            return {
                kind: "storageQualifier",
                CONST,
                CENTROID,
                IN,
                OUT,
                VARYING,
                ATTRIBUTE,
                UNIFORM,
            };
        });
        //SPEC for_init_statement:
        //SPEC     expression_statement
        //SPEC     declaration_statement
        //SPEC conditionopt:
        //SPEC     condition
        //SPEC     /* empty */
        //SPEC for_rest_statement:
        //SPEC     conditionopt SEMICOLON
        //SPEC     conditionopt SEMICOLON expression
        //SPEC jump_statement:
        //SPEC     CONTINUE SEMICOLON
        //SPEC     BREAK SEMICOLON
        //SPEC     RETURN SEMICOLON
        //SPEC     RETURN expression SEMICOLON
        //SPEC     DISCARD SEMICOLON // Fragment shader only.
        //SPEC     invariant_qualifier interpolation_qualifier storage_qualifier
        this.typeQualifier = this.RR("typeQualifier", () => {
            let storageQualifier;
            let layoutQualifier;
            let interpolationQualifier;
            let invariantQualifier;
            this.OR([
                {
                    ALT: () => (storageQualifier = this.SUBRULE(this.storageQualifier)),
                },
                {
                    ALT: () => {
                        layoutQualifier = this.SUBRULE1(this.layoutQualifier);
                        storageQualifier = this.OPTION1(() => this.SUBRULE2(this.storageQualifier));
                    },
                },
                {
                    ALT: () => {
                        interpolationQualifier = this.CONSUME(TOKEN.INTERPOLATION_QUALIFIER);
                        storageQualifier = this.OPTION2(() => this.SUBRULE3(this.storageQualifier));
                    },
                },
                {
                    ALT: () => {
                        // this.SUBRULE(this.invariantQualifier)
                        invariantQualifier = this.CONSUME(TOKEN.INVARIANT);
                        interpolationQualifier = this.OPTION3(() => this.CONSUME1(TOKEN.INTERPOLATION_QUALIFIER));
                        storageQualifier = this.SUBRULE7(this.storageQualifier);
                    },
                },
            ]);
            return {
                kind: "typeQualifier",
                storageQualifier,
                layoutQualifier,
                interpolationQualifier,
                invariantQualifier,
            };
        });
        //SPEC translation_unit:
        //SPEC     external_declaration
        //SPEC     translation_unit external_declaration
        //SPEC external_declaration:
        //SPEC     function_definition
        //SPEC     declaration
        //SPEC function_definition:
        //SPEC     function_prototype compound_statement_no_new_scope
        //SPEC     In general the above grammar describes a super set of the GLSL ES language. Certain constructs that are
        //SPEC     valid purely in terms of the grammar are disallowed by statements elsewhere in this specification.
        //SPEC     Rules specifying the scoping are present only to assist the understanding of scoping and they do not affect
        //SPEC     the language accepted by the grammar. If required, the grammar can be simplified by making the
        //SPEC following substitutions:
        //SPEC     •
        //SPEC
        //SPEC     Replace compound_statement_with_scope and compound_statement_no_new_scope with a new
        //SPEC     rule compound_statement
        //SPEC
        //SPEC     •
        //SPEC
        //SPEC     Replace statement_with_scope and statement_no_new_scope with the existing rule statement.
        this.precisionQualifier = this.RR("precisionQualifier", () => this.CONSUME(TOKEN.PRECISION_QUALIFIER));
        // assignmentExpression: conditionalExpression (assignmentOperator conditionalExpression)*
        this.arraySpecifier = this.RR("arraySpecifier", () => {
            this.CONSUME(TOKEN.LEFT_BRACKET);
            const size = this.OPTION3(() => this.SUBRULE(this.constantExpression));
            this.CONSUME(TOKEN.RIGHT_BRACKET);
            return { kind: "arraySpecifier", size };
        });
        this.typeSpecifierNonArray = this.RR("typeSpecifierNonArray", () => this.OR([
            { ALT: () => this.CONSUME(TOKEN.BASIC_TYPE) },
            { ALT: () => this.CONSUME(TOKEN.VOID) },
            { ALT: () => this.SUBRULE(this.structSpecifier) },
            { ALT: () => this.CONSUME(TOKEN.IDENTIFIER) },
        ]));
        //SPEC     type_specifier_nonarray LEFT_BRACKET constant_expression RIGHT_BRACKET
        this.typeSpecifierNoPrec = this.RR("typeSpecifierNoPrec", () => {
            const typeSpecifierNonArray = this.SUBRULE(this.typeSpecifierNonArray);
            const arraySpecifier = this.OPTION1(() => this.SUBRULE(this.arraySpecifier));
            return {
                kind: "typeSpecifier",
                precisionQualifier: undefined,
                arraySpecifier,
                typeSpecifierNonArray,
            };
        });
        this.functionCall = this.RR("functionCall", () => {
            const callee = this.SUBRULE(this.typeSpecifierNoPrec);
            this.CONSUME(TOKEN.LEFT_PAREN);
            const args = [];
            this.MANY_SEP({
                DEF: () => args.push(this.SUBRULE(this.assignmentExpression)),
                SEP: TOKEN.COMMA,
            });
            this.CONSUME(TOKEN.RIGHT_PAREN);
            return { kind: "functionCall", callee, args };
        });
        // used for lookahead
        this.functionCallHeader = this.RULE("functionCallHeader", () => {
            this.SUBRULE(this.typeSpecifierNoPrec);
            this.CONSUME(TOKEN.LEFT_PAREN);
        });
        // We add postfixExpression DOT functionCall.
        this.postfixExpression = this.RR("postfixExpression", () => {
            const firstToken = this.LA(1);
            let result = this.OR1([
                {
                    GATE: this.BACKTRACK(this.functionCallHeader),
                    ALT: () => this.SUBRULE1(this.functionCall),
                },
                {
                    ALT: () => this.SUBRULE(this.primaryExpression),
                },
            ]);
            this.MANY(() => {
                result = this.OR2([
                    {
                        ALT: () => {
                            this.CONSUME(TOKEN.LEFT_BRACKET);
                            const index = this.SUBRULE(this.expression);
                            this.CONSUME(TOKEN.RIGHT_BRACKET);
                            return { kind: "arrayAccess", on: result, index };
                        },
                    },
                    {
                        ALT: () => {
                            this.CONSUME1(TOKEN.DOT);
                            const functionCall = this.SUBRULE2(this.functionCall);
                            return { kind: "methodCall", on: result, functionCall };
                        },
                    },
                    {
                        ALT: () => {
                            this.CONSUME2(TOKEN.DOT);
                            const field = this.CONSUME(TOKEN.IDENTIFIER);
                            return { kind: "fieldAccess", on: result, field };
                        },
                    },
                    {
                        ALT: () => {
                            const op = this.CONSUME(TOKEN.POSTFIX_OP);
                            return { kind: "postfixExpression", on: result, op };
                        },
                    },
                ]);
                this.FINALIZE(result, firstToken);
            });
            return result;
        });
        //SPEC     unary_operator unary_expression
        this.unaryExpression = this.RR("unaryExpression", () => this.OR([
            { ALT: () => this.SUBRULE1(this.postfixExpression) },
            {
                ALT: () => {
                    const op = this.CONSUME(TOKEN.UNARY_OP);
                    const on = this.SUBRULE2(this.unaryExpression);
                    return { kind: "unaryExpression", op, on };
                },
            },
        ]));
        this.ppUnaryExpression = this.RR("ppUnaryExpression", () => this.OR([
            {
                GATE: () => this.LA(1).tokenType === TOKEN.NON_PP_IDENTIFIER &&
                    this.LA(1).image === "defined",
                ALT: () => {
                    const op = this.CONSUME(TOKEN.IDENTIFIER);
                    const _var = this.OR1([
                        { ALT: () => this.SUBRULE(this.ppIdentifier) },
                        {
                            ALT: () => {
                                this.CONSUME(TOKEN.LEFT_PAREN);
                                const _var = this.SUBRULE1(this.ppIdentifier);
                                this.CONSUME(TOKEN.RIGHT_PAREN);
                                return _var;
                            },
                        },
                    ]);
                    return {
                        kind: "unaryExpression",
                        op,
                        on: { kind: "variableExpression", var: _var },
                    };
                },
            },
            {
                ALT: () => {
                    const op = this.OR2([
                        { ALT: () => this.CONSUME(TOKEN.PLUS) },
                        { ALT: () => this.CONSUME(TOKEN.DASH) },
                        { ALT: () => this.CONSUME(TOKEN.TILDE) },
                        { ALT: () => this.CONSUME(TOKEN.BANG) },
                    ]);
                    const on = this.SUBRULE2(this.ppUnaryExpression);
                    return { kind: "unaryExpression", op, on };
                },
            },
            {
                ALT: () => this.SUBRULE(this.ppPrimaryExpression),
            },
        ]));
        this.ppPrimaryExpression = this.RR("ppPrimaryExpression", () => this.OR([
            {
                ALT: () => ({
                    kind: "variableExpression",
                    var: this.SUBRULE(this.ppIdentifier),
                }),
            },
            {
                ALT: () => ({
                    kind: "constantExpression",
                    const_: this.CONSUME(TOKEN.INTCONSTANT),
                }),
            },
            {
                ALT: () => {
                    this.CONSUME(TOKEN.LEFT_PAREN);
                    const expr = this.SUBRULE(this.ppConstantExpression);
                    this.CONSUME(TOKEN.RIGHT_PAREN);
                    return expr;
                },
            },
        ]));
        this.ppConstantExpression = this.RR("ppConstantExpression", () => {
            try {
                this.preprocessing = true;
                return this.LEFT_ASSOC(this.logicalAndExpression, TOKEN.OR_OP);
            }
            finally {
                this.preprocessing = false;
            }
        });
        this.typeSpecifier = this.RR("typeSpecifier", () => {
            const precisionQualifier = this.OPTION(() => this.SUBRULE(this.precisionQualifier));
            const typeSpecifierNoPrec = this.SUBRULE(this.typeSpecifierNoPrec);
            return Object.assign({}, typeSpecifierNoPrec, { precisionQualifier });
        });
        //SPEC     type_specifier
        this.parameterDeclaration = this.RR("parameterDeclaration", () => {
            //     constQualifier
            const parameterTypeQualifier = this.OPTION(() => this.CONSUME(TOKEN.CONST));
            //     parameterQualifier
            const parameterQualifier = this.OPTION1(() => this.CONSUME(TOKEN.PARAMETER_QUALIFIER));
            const typeSpecifier = this.SUBRULE(this.typeSpecifier);
            let pName, arraySpecifier;
            this.OPTION2(() => {
                pName = this.CONSUME2(TOKEN.IDENTIFIER);
                //arraySpecifier
                arraySpecifier = this.OPTION3(() => this.SUBRULE(this.arraySpecifier));
            });
            return {
                kind: "parameterDeclaration",
                parameterTypeQualifier,
                pName,
                arraySpecifier,
                parameterQualifier,
                typeSpecifier,
            };
        });
        this.fullySpecifiedType = this.RR("fullySpecifiedType", () => {
            const typeQualifier = this.OPTION(() => this.SUBRULE(this.typeQualifier));
            const typeSpecifier = this.SUBRULE(this.typeSpecifier);
            return { kind: "fullySpecifiedType", typeQualifier, typeSpecifier };
        });
        this.structDeclaration = this.RR("structDeclaration", () => {
            const fsType = this.SUBRULE(this.fullySpecifiedType);
            const declarators = [];
            this.MANY_SEP({
                SEP: TOKEN.COMMA,
                DEF: this.ANNOTATE(() => {
                    const declarator = {
                        kind: "declarator",
                        name: this.CONSUME(TOKEN.IDENTIFIER),
                        arraySpecifier: this.OPTION(() => this.SUBRULE(this.arraySpecifier)),
                        init: undefined,
                    };
                    declarators.push(declarator);
                    return declarator;
                }),
            });
            this.CONSUME(TOKEN.SEMICOLON);
            return { kind: "structDeclaration", fsType, declarators };
        });
        this.structSpecifier = this.RR("structSpecifier", () => {
            this.CONSUME(TOKEN.STRUCT);
            const name = this.OPTION2(() => this.CONSUME(TOKEN.IDENTIFIER));
            this.CONSUME(TOKEN.LEFT_BRACE);
            const declarations = [];
            this.MANY(() => declarations.push(this.SUBRULE(this.structDeclaration)));
            this.CONSUME(TOKEN.RIGHT_BRACE);
            return { kind: "structSpecifier", name, declarations };
        });
        this.initializer = this.RR("initializer", () => this.SUBRULE(this.assignmentExpression));
        this.singleDeclaration = this.RULE("singleDeclaration", () => this.OR([
            {
                ALT: () => {
                    this.SUBRULE(this.fullySpecifiedType);
                    this.OPTION1(() => {
                        this.CONSUME1(TOKEN.IDENTIFIER);
                        this.OPTION2(() => {
                            this.CONSUME(TOKEN.LEFT_BRACKET);
                            this.OPTION3(() => this.SUBRULE(this.constantExpression));
                            this.CONSUME(TOKEN.RIGHT_BRACKET);
                        });
                        this.OPTION4(() => {
                            this.CONSUME(TOKEN.EQUAL);
                            this.SUBRULE(this.initializer);
                        });
                    });
                },
            },
            {
                ALT: () => ({
                    // TODO this need to be followed by MANY
                    kind: "invariantDeclaration",
                    INVARIANT: this.CONSUME(TOKEN.INVARIANT),
                    IDENTIFIER: this.CONSUME2(TOKEN.IDENTIFIER),
                }),
            },
        ]));
        this.initDeclaratorList = this.RR("initDeclaratorList", () => this.SUBRULE(this.externalDeclaration, {
            ARGS: [false, false],
        }));
        this.expressionStatement = this.RR("expressionStatement", () => {
            const expression = this.OPTION(() => this.SUBRULE(this.expression));
            this.CONSUME(TOKEN.SEMICOLON);
            return { kind: "expressionStatement", expression };
        });
        // simplify to expression | declaration and check in checker
        this.condition = this.RR("condition", () => this.OR({
            MAX_LOOKAHEAD: 4,
            DEF: [
                {
                    GATE: this.BACKTRACK(this.singleDeclaration),
                    // TODO
                    // ALT: () => {
                    //   this.SUBRULE2(this.fullySpecifiedType)
                    //   this.CONSUME(TOKEN.IDENTIFIER)
                    //   this.CONSUME(TOKEN.EQUAL)
                    //   this.SUBRULE3(this.initializer)
                    // },
                    ALT: () => {
                        const fsType = this.SUBRULE2(this.fullySpecifiedType);
                        const name = this.CONSUME(TOKEN.IDENTIFIER);
                        this.CONSUME(TOKEN.EQUAL);
                        const init = this.SUBRULE3(this.initializer);
                        return {
                            kind: "initDeclaratorListDeclaration",
                            fsType,
                            declarators: [
                                { kind: "declarator", name, init, arraySpecifier: undefined },
                            ],
                        };
                    },
                },
                {
                    ALT: () => this.SUBRULE(this.expression),
                },
            ],
        }));
        this.caseLabel = this.RR("caseLabel", () => this.OR([
            {
                ALT: () => {
                    this.CONSUME(TOKEN.CASE);
                    const case_ = this.SUBRULE(this.expression);
                    this.CONSUME(TOKEN.COLON);
                    return { kind: "caseLabel", case_ };
                },
            },
            {
                ALT: () => {
                    this.CONSUME2(TOKEN.DEFAULT);
                    this.CONSUME2(TOKEN.COLON);
                    return { kind: "caseLabel", case_: undefined };
                },
            },
        ]));
        this.selectionStatement = this.RR("selectionStatement", () => {
            this.CONSUME(TOKEN.IF);
            this.CONSUME(TOKEN.LEFT_PAREN);
            const condition = this.SUBRULE(this.expression);
            this.CONSUME(TOKEN.RIGHT_PAREN);
            const yes = this.SUBRULE2(this.statement, { ARGS: [true] });
            const no = this.OPTION(() => {
                this.CONSUME(TOKEN.ELSE);
                return this.SUBRULE3(this.statement, { ARGS: [true] });
            });
            return { kind: "selectionStatement", condition, yes, no };
        });
        this.statement = this.RR("statement", (newScope) => this.OR([
            {
                ALT: () => this.SUBRULE(this.ppDirective),
                IGNORE_AMBIGUITIES: true,
            },
            {
                // We want "IDENTIFIER ;" to be parsed as a variableExpression, so
                // we add a special rule here.
                ALT: () => {
                    const v = this.CONSUME(TOKEN.IDENTIFIER);
                    this.CONSUME(TOKEN.SEMICOLON);
                    return {
                        kind: "expressionStatement",
                        expression: { kind: "variableExpression", var: v },
                    };
                },
                IGNORE_AMBIGUITIES: true,
            },
            // Attempt to parse expressionStatement first, so that ambiguities
            // are resolved as expressions.
            {
                GATE: this.BACKTRACK(this.expressionStatement),
                ALT: () => this.SUBRULE(this.expressionStatement),
            },
            // declarationStatement
            { ALT: () => this.SUBRULE(this.initDeclaratorList) },
            { ALT: () => this.SUBRULE(this.selectionStatement) },
            { ALT: () => this.SUBRULE(this.switchStatement) },
            // { ALT: () => this.SUBRULE(this.caseLabel) }, TODO
            { ALT: () => this.SUBRULE(this.iterationStatement) },
            { ALT: () => this.SUBRULE(this.jumpStatement) },
            {
                ALT: () => this.SUBRULE(this.compoundStatement, { ARGS: [!!newScope] }),
            },
        ]));
        this.compoundStatement = this.RR("compoundStatement", (newScope) => {
            if (typeof newScope === "object") {
                throw new Error();
            }
            this.CONSUME(TOKEN.LEFT_BRACE);
            const statements = [];
            this.MANY(() => statements.push(this.SUBRULE(this.statement)));
            this.CONSUME(TOKEN.RIGHT_BRACE);
            return { kind: "compoundStatement", statements, newScope: !!newScope };
        });
        //SPEC     FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope
        this.iterationStatement = this.RR("iterationStatement", () => this.OR([
            {
                ALT: () => {
                    this.CONSUME(TOKEN.WHILE);
                    this.CONSUME(TOKEN.LEFT_PAREN);
                    const conditionExpression = this.SUBRULE(this.condition);
                    this.CONSUME(TOKEN.RIGHT_PAREN);
                    const statement = this.SUBRULE(this.statement);
                    return { kind: "whileStatement", conditionExpression, statement };
                },
            },
            {
                ALT: () => {
                    this.CONSUME2(TOKEN.DO);
                    const statement = this.SUBRULE2(this.statement, { ARGS: [true] });
                    this.CONSUME2(TOKEN.WHILE);
                    this.CONSUME2(TOKEN.LEFT_PAREN);
                    const conditionExpression = this.SUBRULE2(this.expression);
                    this.CONSUME2(TOKEN.RIGHT_PAREN);
                    this.CONSUME2(TOKEN.SEMICOLON);
                    return { kind: "doWhileStatement", statement, conditionExpression };
                },
            },
            {
                ALT: () => {
                    this.CONSUME3(TOKEN.FOR);
                    this.CONSUME3(TOKEN.LEFT_PAREN);
                    const initExpression = this.OR3([
                        {
                            GATE: this.BACKTRACK(this.initDeclaratorList),
                            ALT: () => this.SUBRULE(this.initDeclaratorList),
                        },
                        {
                            ALT: () => this.SUBRULE(this.expressionStatement),
                        },
                    ]);
                    const conditionExpression = this.OPTION3(() => this.SUBRULE3(this.condition));
                    this.CONSUME4(TOKEN.SEMICOLON);
                    const loopExpression = this.OPTION4(() => this.SUBRULE4(this.expression));
                    this.CONSUME3(TOKEN.RIGHT_PAREN);
                    const statement = this.SUBRULE3(this.statement);
                    return {
                        kind: "forStatement",
                        initExpression,
                        conditionExpression,
                        loopExpression,
                        statement,
                    };
                },
            },
        ]));
        this.translationUnit = this.RR("translationUnit", () => {
            const declarations = [];
            this.AT_LEAST_ONE(() => declarations.push(this.SUBRULE(this.externalDeclaration, { ARGS: [true, true] })));
            return { kind: "translationUnit", declarations };
        });
        this.uniformBlock = this.RR("uniformBlock", () => {
            // this.CONSUME(TOKEN.UNIFORM)
            const typeQualifier = this.SUBRULE(this.typeQualifier);
            const blockName = this.CONSUME(TOKEN.IDENTIFIER);
            this.CONSUME(TOKEN.LEFT_BRACE);
            const declarations = [];
            this.MANY(() => declarations.push(this.SUBRULE(this.structDeclaration)));
            this.CONSUME(TOKEN.RIGHT_BRACE);
            let namespace;
            let arraySpecifier;
            this.OPTION(() => {
                namespace = this.CONSUME1(TOKEN.IDENTIFIER);
                arraySpecifier = this.OPTION1(() => this.SUBRULE(this.arraySpecifier));
            });
            this.CONSUME(TOKEN.SEMICOLON);
            return {
                kind: "uniformBlock",
                typeQualifier,
                blockName,
                declarations,
                namespace,
                arraySpecifier,
            };
        });
        // Minimum rule we need to test if a uniformBlock is next.
        this.uniformBlockHeader = this.RULE("uniformBlockHeader", () => {
            this.OPTION(() => this.SUBRULE(this.layoutQualifier));
            this.CONSUME(TOKEN.UNIFORM);
            this.CONSUME(TOKEN.IDENTIFIER);
            this.CONSUME(TOKEN.LEFT_BRACE);
        });
        this.typeQualifierDeclaration = this.RR("typeQualifierDeclaration", () => {
            const typeQualifier = this.SUBRULE(this.typeQualifier);
            this.CONSUME(TOKEN.SEMICOLON);
            return { kind: "typeQualifierDeclaration", typeQualifier };
        });
        this.externalDeclaration = this.RR("externalDeclaration", (uniformBlock, function_) => this.OR([
            { ALT: () => this.SUBRULE(this.ppCall) },
            { ALT: () => this.SUBRULE(this.ppDirective) },
            // type qualifier declaration
            {
                GATE: this.BACKTRACK(this.typeQualifierDeclaration),
                ALT: () => this.SUBRULE(this.typeQualifierDeclaration),
            },
            // uniform/interface block
            {
                GATE: uniformBlock
                    ? this.BACKTRACK(this.uniformBlockHeader)
                    : () => false,
                ALT: () => this.SUBRULE(this.uniformBlock),
            },
            // initDeclaratorList, functionPrototype or functionDefinition
            {
                ALT: () => {
                    const type = this.SUBRULE(this.fullySpecifiedType);
                    return this.OR2([
                        // functionPrototype
                        {
                            GATE: function_ ? undefined : () => false,
                            ALT: () => {
                                const name = this.CONSUME1(TOKEN.IDENTIFIER);
                                this.CONSUME(TOKEN.LEFT_PAREN);
                                const params = [];
                                this.MANY_SEP({
                                    SEP: TOKEN.COMMA,
                                    DEF: () => params.push(this.SUBRULE(this.parameterDeclaration)),
                                });
                                this.CONSUME(TOKEN.RIGHT_PAREN);
                                return this.OR3([
                                    {
                                        ALT: () => {
                                            this.CONSUME(TOKEN.SEMICOLON);
                                            return {
                                                kind: "functionPrototype",
                                                name,
                                                returnType: type,
                                                params,
                                            };
                                        },
                                    },
                                    {
                                        // GATE: () => !noFunctionDefinition,
                                        ALT: () => {
                                            const body = this.SUBRULE(this.compoundStatement);
                                            return {
                                                kind: "functionDefinition",
                                                name,
                                                returnType: type,
                                                params,
                                                body,
                                            };
                                        },
                                        IGNORE_AMBIGUITIES: false,
                                    },
                                ]);
                            },
                        },
                        // initDeclaratorList
                        {
                            ALT: () => {
                                const declarators = [];
                                this.MANY_SEP2({
                                    SEP: TOKEN.COMMA,
                                    DEF: this.ANNOTATE(() => {
                                        const name = this.CONSUME3(TOKEN.IDENTIFIER);
                                        const arraySpecifier = this.OPTION5(() => this.SUBRULE(this.arraySpecifier));
                                        const init = this.OPTION7(() => {
                                            this.CONSUME(TOKEN.EQUAL);
                                            return this.SUBRULE(this.initializer);
                                        });
                                        const declarator = {
                                            kind: "declarator",
                                            name,
                                            arraySpecifier,
                                            init,
                                        };
                                        declarators.push(declarator);
                                        return declarator;
                                    }),
                                });
                                this.CONSUME2(TOKEN.SEMICOLON);
                                return {
                                    kind: "initDeclaratorListDeclaration",
                                    fsType: type,
                                    declarators,
                                };
                            },
                        },
                    ]);
                },
            },
            // precisionQualifier
            {
                ALT: () => {
                    this.CONSUME(TOKEN.PRECISION);
                    const precisionQualifier = this.CONSUME(TOKEN.PRECISION_QUALIFIER);
                    const typeSpecifierNoPrec = this.SUBRULE(this.typeSpecifierNoPrec);
                    this.CONSUME3(TOKEN.SEMICOLON);
                    return {
                        kind: "precisionDeclaration",
                        precisionQualifier,
                        typeSpecifierNoPrec,
                    };
                },
            },
        ]));
        this.ppDefine = this.RR("ppDefine", () => {
            this.CONSUME(TOKEN.HASH);
            this.CONSUME(TOKEN.DEFINE);
            const what = this.CONSUME(TOKEN.IDENTIFIER);
            const isFunctionMacro = this.LA(1).tokenType === TOKEN.LEFT_PAREN &&
                what.endOffset + 1 === this.LA(1).startOffset;
            const params = this.OPTION({
                GATE: () => isFunctionMacro,
                DEF: () => {
                    this.CONSUME(TOKEN.LEFT_PAREN);
                    const params = [];
                    this.MANY_SEP({
                        SEP: TOKEN.COMMA,
                        DEF: () => params.push(this.SUBRULE(this.ppIdentifier)),
                    });
                    this.CONSUME(TOKEN.RIGHT_PAREN);
                    return params;
                },
            });
            const tokens = this.getTokensOnLine();
            const d = {
                kind: "ppDefine",
                what,
                params,
                tokens,
                node: undefined,
            };
            this.ppDefs.push(d);
            return d;
        });
        this.ppInclude = this.RR("ppInclude", () => {
            this.CONSUME(TOKEN.HASH);
            this.CONSUME(TOKEN.INCLUDE);
            const str = this.CONSUME(TOKEN.STRING);
            return { kind: "ppInclude", what: str };
        });
        this.ppCall = this.RR("ppCall", () => {
            const callee = this.CONSUME(TOKEN.IDENTIFIER);
            this.CONSUME(TOKEN.LEFT_PAREN);
            const args = [];
            this.MANY_SEP({
                SEP: TOKEN.COMMA,
                DEF: () => {
                    const tokens = [];
                    this.MANY(() => this.OR({
                        // IGNORE_AMBIGUITIES: true,
                        DEF: [
                            {
                                ALT: () => {
                                    const tt = this.SUBRULE(this.ppCallArg);
                                    this.ACTION(() => tokens.push(...tt));
                                },
                            },
                            { ALT: () => tokens.push(this.CONSUME(TOKEN.BASIC_TYPE)) },
                            { ALT: () => tokens.push(this.CONSUME(TOKEN.ASSIGN_OP)) },
                            { ALT: () => tokens.push(this.CONSUME(TOKEN.SHIFT_OP)) },
                            { ALT: () => tokens.push(this.CONSUME(TOKEN.CONSTANT)) },
                            { ALT: () => tokens.push(this.CONSUME(TOKEN.KEYWORD)) },
                            { ALT: () => tokens.push(this.CONSUME2(TOKEN.IDENTIFIER)) },
                        ],
                    }));
                    args.push({ tokens, node: undefined });
                },
                MAX_LOOKAHEAD: 1,
            });
            this.CONSUME(TOKEN.RIGHT_PAREN);
            return { kind: "ppCall", callee, args };
        });
        this.ppCallArg = this.RULE("ppCallArg", () => {
            const tokens = [];
            tokens.push(this.CONSUME(TOKEN.LEFT_PAREN));
            this.MANY(() => this.OR([
                {
                    ALT: () => {
                        const tt = this.SUBRULE(this.ppCallArg);
                        this.ACTION(() => tokens.push(...tt));
                    },
                },
                {
                    // GATE: () => this.LA(1).tokenType !== TOKEN.COMMA,
                    ALT: () => {
                        tokens.push(this.LA(1));
                        return this.SKIP_TOKEN();
                    },
                },
            ]));
            tokens.push(this.CONSUME(TOKEN.RIGHT_PAREN));
            return tokens;
        });
        this.ppNone = this.RR("ppNone", () => {
            this.CONSUME(TOKEN.HASH);
            const dir = this.OR([
                { ALT: () => this.CONSUME(TOKEN.ELSE) },
                { ALT: () => this.CONSUME(TOKEN.ENDIF) },
            ]);
            const d = { kind: "ppDir", dir, tokens: [], node: undefined };
            this.ppDefs.push(d);
            return d;
        });
        this.ppMulti = this.RR("ppMulti", () => {
            this.CONSUME(TOKEN.HASH);
            const dir = this.OR([
                { ALT: () => this.CONSUME(TOKEN.IF) },
                { ALT: () => this.CONSUME(TOKEN.ELIF) },
                { ALT: () => this.CONSUME(TOKEN.ERROR) },
                { ALT: () => this.CONSUME(TOKEN.VERSION) },
                { ALT: () => this.CONSUME(TOKEN.LINE) },
            ]);
            const tokens = this.getTokensOnLine();
            const d = { kind: "ppDir", dir, tokens, node: undefined };
            this.ppDefs.push(d);
            return d;
        });
        this.ppPragma = this.RR("ppPragma", () => {
            const dir = this.CONSUME(TOKEN.PRAGMA_DIRECTIVE);
            return { kind: "ppPragma", dir };
        });
        this.ppSingle = this.RR("ppSingle", () => {
            this.CONSUME(TOKEN.HASH);
            const dir = this.OR([
                { ALT: () => this.CONSUME(TOKEN.IFDEF) },
                { ALT: () => this.CONSUME(TOKEN.IFNDEF) },
            ]);
            const token = this.CONSUME(TOKEN.IDENTIFIER);
            return { kind: "ppDir", dir, tokens: [token], node: undefined };
        });
        this.ppExtension = this.RR("ppExtension", () => {
            this.CONSUME(TOKEN.HASH);
            this.CONSUME(TOKEN.EXTENSION);
            const extension = this.CONSUME(TOKEN.IDENTIFIER);
            this.CONSUME(TOKEN.COLON);
            const behavior = this.CONSUME1(TOKEN.IDENTIFIER);
            return { kind: "ppExtension", extension, behavior };
        });
        this.ppDirective = this.RR("ppDirective", () => this.OR([
            { ALT: () => this.SUBRULE(this.ppDefine) },
            { ALT: () => this.SUBRULE(this.ppExtension) },
            { ALT: () => this.SUBRULE(this.ppNone) },
            { ALT: () => this.SUBRULE(this.ppSingle) },
            { ALT: () => this.SUBRULE(this.ppMulti) },
            { ALT: () => this.SUBRULE(this.ppPragma) },
            { ALT: () => this.SUBRULE(this.ppInclude) },
        ]));
        this.ppIdentifier = this.RR("ppIdentifier", () => this.OR([
            { ALT: () => this.CONSUME(TOKEN.IDENTIFIER) },
            { ALT: () => this.CONSUME(TOKEN.KEYWORD) },
            { ALT: () => this.CONSUME(TOKEN.BASIC_TYPE) },
        ]));
        this.ppDefs = [];
        this.performSelfAnalysis();
    }
    reset() {
        super.reset();
        this.ppDefs = [];
        this.backtracking = false;
        this.preprocessing = false;
    }
    LEFT_ASSOC(rule, tok) {
        const firstToken = this.LA(1);
        let result = this.SUBRULE1(rule);
        this.MANY(() => {
            const op = this.CONSUME(tok);
            const rhs = this.SUBRULE2(rule);
            result = {
                kind: "binaryExpression",
                lhs: result,
                rhs,
                op,
                firstToken,
                lastToken: this.LA(0),
            };
            return result;
        });
        return result;
    }
    ANNOTATE(implementation) {
        return (...args) => {
            const firstToken = this.LA(1);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const result = implementation(...args);
            if (result && isNode(result) && !result.firstToken) {
                this.FINALIZE(result, firstToken);
            }
            return result;
        };
    }
    BACKTRACK(grammarRule, args) {
        const backtrack = super.BACKTRACK(grammarRule, args);
        return function () {
            try {
                this.backtracking = true;
                return backtrack.call(this);
            }
            finally {
                this.backtracking = false;
            }
        };
    }
    RR(name, implementation, config) {
        return super.RULE(name, this.ANNOTATE(implementation), config);
    }
    FINALIZE(n, firstToken) {
        if (!this.RECORDING_PHASE && !this.backtracking) {
            n.firstToken = firstToken;
            n.lastToken = this.LA(0);
        }
    }
    isAtEof() {
        return this.LA(1).tokenType === chevrotain.EOF;
    }
}
// ONLY ONCE
const GLSL_PARSER = new GLSLParser();
function checkParsingErrors(input, errors) {
    if (errors.length > 0) {
        throw new Error("PARSE ERROR: " +
            errors
                .map((e) => e.message +
                "\n" +
                e.context.ruleStack.join(" > ") +
                "\n" +
                substrContext(input, e.token))
                .join("\n"));
    }
}
function checkTokenErrors(lexingResult) {
    function markError(where, err, msg) {
    }
    for (const token of lexingResult.tokens) {
        if (token.tokenType === TOKEN.NON_PP_IDENTIFIER) {
            if (token.image.includes("__")) ;
            else if (RESERVED_KEYWORDS.includes(token.image)) {
                markError(token, token.image + " is a reserved keyword.");
            }
            else if (token.image.length > 1024) ;
        }
    }
}
function parseInput(originalInput) {
    const noLineCont = applyLineContinuations(originalInput);
    const lexingResult = GLSL_LEXER.tokenize(noLineCont.result);
    checkLexingErrors(noLineCont.result, lexingResult);
    fixLocations(lexingResult.tokens, noLineCont.changes);
    checkTokenErrors(lexingResult);
    // "input" is a setter which will reset the glslParser's state.
    GLSL_PARSER.input = lexingResult.tokens;
    const result = GLSL_PARSER.translationUnit();
    checkParsingErrors(noLineCont.result, GLSL_PARSER.errors);
    const ppDefs = GLSL_PARSER.ppDefs;
    function tryParse(tokens, rule) {
        GLSL_PARSER.input = tokens;
        const result = rule(GLSL_PARSER);
        if (GLSL_PARSER.isAtEof() && GLSL_PARSER.errors.length === 0) {
            return result;
        }
        else {
            return undefined;
        }
    }
    for (const ppDef of ppDefs) {
        ppDef.node =
            tryParse(ppDef.tokens, (p) => p.externalDeclaration(true, true)) ??
                tryParse(ppDef.tokens, (p) => p.statement()) ??
                tryParse(ppDef.tokens, (p) => p.expression());
    }
    result.comments = lexingResult.groups.COMMENTS;
    return result;
}

function getMatrixDimensions(t) {
    switch (t) {
        case TOKEN.MAT2X2:
            return [2, 2];
        case TOKEN.MAT2X3:
            return [2, 3];
        case TOKEN.MAT2X4:
            return [2, 4];
        case TOKEN.MAT3X2:
            return [3, 2];
        case TOKEN.MAT3X3:
            return [3, 3];
        case TOKEN.MAT3X4:
            return [3, 4];
        case TOKEN.MAT4X2:
            return [4, 2];
        case TOKEN.MAT4X3:
            return [4, 3];
        case TOKEN.MAT4X4:
            return [4, 4];
        default:
            return undefined;
    }
}

// noinspection JSUnusedGlobalSymbols
const { utils: { propagateBreaks }, printer: { printDocToString }, builders: { indentIfBreak, group, indent, join, line, softline, hardline, fill, lineSuffixBoundary, }, } = doc__namespace;
const CHILDREN_VISITOR = new (class extends AbstractVisitor {
    constructor() {
        super(...arguments);
        this.result = undefined;
    }
    visit(n) {
        if (this.result) {
            if (n) {
                this.result.push(n);
            }
            return undefined;
        }
        else {
            const result = (this.result = []);
            super.visit(n);
            this.result = undefined;
            return result;
        }
    }
})();
const languages = [
    {
        name: "glsl",
        parsers: ["glsl-parser"],
        // https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
        extensions: [
            ".glsl",
            ".fp",
            ".frag",
            ".frg",
            ".fs",
            ".fsh",
            ".fshader",
            ".geo",
            ".geom",
            ".glslf",
            ".glslv",
            ".gs",
            ".gshader",
            ".rchit",
            ".rmiss",
            ".shader",
            ".tesc",
            ".tese",
            ".vert",
            ".vrx",
            ".vsh",
            ".vshader",
        ],
    },
];
function locStart(node) {
    return (isToken(node) ? node : node.firstToken).startOffset;
}
function locEnd(node) {
    return (isToken(node) ? node : node.lastToken).endOffset + 1;
}
const parsers = {
    "glsl-parser": {
        parse(text, _parsers, _options) {
            const translationUnit = parseInput(text);
            translationUnit.comments?.forEach((c) => (c.value = JSON.stringify(c)));
            return translationUnit;
        },
        astFormat: "glsl-ast",
        locStart,
        locEnd,
    },
};
function normalizeFloat(image) {
    const dot = image.indexOf(".");
    // .xxx => 0.xxx
    if (dot === 0) {
        image = "0" + image;
    }
    // xEx => xex
    image = image.replace("E", "e");
    if (dot !== -1) {
        // x.exxx => xexxx
        image = image.replace(".e", "e");
        // x.x000 => x.x
        image = image.replace(/0+$/, "");
        // x. => x.0
        image = image.replace(/\.$/, ".0");
        // xe00x => xex
        image = image.replace(/e0+/, "e");
    }
    // xe+x => xex
    image = image.replace("e+", "e");
    return image;
}
function getOpPrecedence(op) {
    switch (op) {
        case TOKEN.STAR:
        case TOKEN.SLASH:
        case TOKEN.PERCENT:
            return 4;
        case TOKEN.PLUS:
        case TOKEN.DASH:
            return 5;
        case TOKEN.LEFT_OP:
        case TOKEN.RIGHT_OP:
            return 6;
        case TOKEN.LEFT_ANGLE:
        case TOKEN.RIGHT_ANGLE:
        case TOKEN.LE_OP:
        case TOKEN.GE_OP:
            return 7;
        case TOKEN.EQ_OP:
        case TOKEN.NE_OP:
            return 8;
        case TOKEN.AMPERSAND:
            return 9;
        case TOKEN.CARET:
            return 10;
        case TOKEN.VERTICAL_BAR:
            return 11;
        case TOKEN.AND_OP:
            return 12;
        case TOKEN.XOR_OP:
            return 12;
        case TOKEN.OR_OP:
            return 13;
        case TOKEN.COMMA:
            return 17;
        default:
            throw new Error();
    }
}
function getPrecedence(n, inMacro) {
    switch (n.kind) {
        default:
            return 1;
        case "variableExpression":
            return inMacro?.find((t) => t.image === n.var.image) ? 18 : 1;
        case "arrayAccess":
        case "functionCall":
        case "fieldAccess":
        case "postfixExpression":
            return 2;
        case "unaryExpression":
            return 3;
        case "binaryExpression":
            return getOpPrecedence(n.op.tokenType);
        case "conditionalExpression":
            return 15;
        case "assignmentExpression":
            return 16;
        case "commaExpression":
            return 17;
    }
}
function paren(doc, cond) {
    return cond ? ["(", doc, ")"] : doc;
}
function printBinaryishExpressions(path, print, n, inMacro) {
    // Binary operation chains with the same operator precedence should either
    // completely break or not at all. E.g. a + b + ccccccccccccc should be
    // "a +\nb +\nccccccccccccc", not "a + b + \nccccccccccccc".
    const shouldFlatten = (n.kind === "binaryExpression" &&
        n.lhs.kind === "binaryExpression" &&
        getOpPrecedence(n.lhs.op.tokenType) ===
            getOpPrecedence(n.op.tokenType)) ||
        (n.kind === "commaExpression" && n.lhs.kind === "commaExpression");
    const nOp = n.kind === "binaryExpression" ? n.op.tokenType : TOKEN.COMMA;
    let parts;
    if (shouldFlatten) {
        // call printBinaryishExpressions to avoid the result being wrapped in group().
        // lhs never needs to be wrapped in paren as we are on same level.
        parts = path.call((path) => printBinaryishExpressions(path, print, path.getValue(), inMacro), "lhs");
        parts.push(" ", path.call(print, "op"), line, paren(path.call(print, "rhs"), getPrecedence(n.rhs, inMacro) >= getOpPrecedence(nOp)));
        return parts;
    }
    else {
        const lhsDoc = path.call(print, "lhs");
        return [
            paren(lhsDoc, getPrecedence(n.lhs, inMacro) > getOpPrecedence(nOp)),
            n.kind === "commaExpression" ? "," : [" ", path.call(print, "op")],
            line,
            paren(path.call(print, "rhs"), getPrecedence(n.rhs, inMacro) >= getOpPrecedence(nOp)),
        ];
    }
}
function adjustClause(node, clause, forceSpace) {
    if (node.kind === "expressionStatement" && !node.expression) {
        return ";";
    }
    if (node.kind === "compoundStatement" || forceSpace) {
        return [" ", clause];
    }
    return indent([line, clause]);
}
function formatMacroDefinition(doc, options) {
    propagateBreaks(doc);
    const formatted = printDocToString(doc, Object.assign({}, options, {
        printWidth: options.printWidth - 2,
    })).formatted;
    return formatted
        .trim()
        .replace(/^.*(?=[\r\n])/gm, (substr) => substr + " ".repeat(options.printWidth - 2 - substr.length + 1) + "\\");
}
function isAssignment(node) {
    return node.kind === "assignmentExpression";
}
function isAssignmentOrVariableDeclarator(node) {
    return node.kind === "assignmentExpression" || node.kind === "declarator";
}
function hasLeadingOwnLineComment(originalText, rightNode) {
    // TODO
    return false;
}
function chooseAssignmentLayout(path, options, rightNode) {
    if (!rightNode) {
        return "only-left";
    }
    // Short assignment chains (only 2 segments) are NOT formatted as chains.
    //   1) a = b = c; (expression statements)
    //   2) int a = b = c;
    const isTail = !isAssignment(rightNode);
    const shouldUseChainFormatting = path.match(isAssignment, isAssignmentOrVariableDeclarator, (node) => !isTail ||
        (node.kind !== "expressionStatement" &&
            node.kind !== "initDeclaratorListDeclaration"));
    if (shouldUseChainFormatting) {
        return !isTail ? "chain" : "chain-tail";
    }
    const isHeadOfLongChain = !isTail && isAssignment(rightNode.rhs);
    if (isHeadOfLongChain ||
        hasLeadingOwnLineComment(options.originalText)) {
        return "break-after-operator";
    }
    if (rightNode.kind === "binaryExpression" ||
        rightNode.kind === "commaExpression" ||
        (rightNode.kind === "conditionalExpression" &&
            rightNode.condition.kind === "binaryExpression")) {
        return "break-after-operator";
    }
    if (rightNode.kind === "constantExpression") {
        return "never-break-after-operator";
    }
    return "fluid";
}
/**
 * Print an `AssignmentExpression` or a variable `Declarator`.
 */
function printAssignmentLike(path, options, leftDoc, operator, rightDoc, rightNode) {
    const layout = chooseAssignmentLayout(path, options, rightNode);
    // TODO: need this group?
    // return group([
    //   name,
    //   arraySpecifier,
    //   " =",
    //   group(indent(line), { id: groupId }),
    //   indentIfBreak(p<typeof n>("init"), { groupId }),
    // ])
    switch (layout) {
        // First break after operator, then the sides are broken independently on their own lines
        case "break-after-operator":
            return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);
        // First break right-hand side, then left-hand side
        case "never-break-after-operator":
            return group([group(leftDoc), operator, " ", rightDoc]);
        // First break right-hand side, then after operator
        case "fluid": {
            const groupId = Symbol("assignment");
            return group([
                group(leftDoc),
                operator,
                group(indent(line), { id: groupId }),
                lineSuffixBoundary,
                indentIfBreak(rightDoc, { groupId }),
            ]);
        }
        // Parts of assignment chains aren't wrapped in groups.
        // Once one of them breaks, the chain breaks too.
        case "chain":
            return [group(leftDoc), operator, line, rightDoc];
        case "chain-tail":
            return [group(leftDoc), operator, indent([line, rightDoc])];
        case "only-left":
            return leftDoc;
        default:
            throw new Error();
    }
}
const printers = {
    "glsl-ast": {
        print(path, options, print) {
            const inMacro = options.inMacro;
            const n = path.getValue();
            if (!n) {
                return [];
            }
            if (isToken(n)) {
                return n.image;
            }
            const p = (s) => path.call(print, s);
            /**
             * Print function calls to mat* with literals as a grid.
             */
            function printFunctionCall(n) {
                const argDocs = path.map(print, "args");
                let mDim;
                let argParts;
                if (n.callee.arraySpecifier === undefined &&
                    isToken(n.callee.typeSpecifierNonArray) &&
                    (mDim = getMatrixDimensions(n.callee.typeSpecifierNonArray.tokenType)) !== undefined &&
                    mDim[0] * mDim[1] === n.args.length) {
                    const allArgsAreConstants = n.args.every((e) => (e.kind === "constantExpression" &&
                        (e.const_.tokenType === TOKEN.FLOATCONSTANT ||
                            e.const_.tokenType === TOKEN.INTCONSTANT)) ||
                        (e.kind === "unaryExpression" &&
                            (e.op.tokenType === TOKEN.PLUS ||
                                e.op.tokenType === TOKEN.DASH) &&
                            e.on.kind === "constantExpression" &&
                            (e.on.const_.tokenType === TOKEN.FLOATCONSTANT ||
                                e.on.const_.tokenType === TOKEN.INTCONSTANT)));
                    if (allArgsAreConstants) {
                        const suffixes = [];
                        const prefixes = [];
                        let maxPrefix = 0;
                        let maxSuffix = 0;
                        for (let i = 0; i < n.args.length; i++) {
                            const printedArg = argDocs[i];
                            let periodIndex = typeof printedArg === "string"
                                ? printedArg.indexOf(".")
                                : 1 + printedArg[1].indexOf(".");
                            if (periodIndex === -1) {
                                periodIndex =
                                    typeof printedArg === "string"
                                        ? printedArg.length
                                        : 1 + printedArg[1].length;
                            }
                            prefixes[i] = periodIndex;
                            suffixes[i] =
                                (typeof printedArg === "string"
                                    ? printedArg.length
                                    : 1 + printedArg[1].length) - periodIndex;
                            maxPrefix = Math.max(maxPrefix, prefixes[i]);
                            maxSuffix = Math.max(maxSuffix, suffixes[i]);
                        }
                        argParts = [];
                        const colCount = mDim[0];
                        for (let i = 0; i < argDocs.length; i++) {
                            const leftPad = maxPrefix - prefixes[i];
                            const rightPad = maxSuffix - suffixes[i];
                            const alignedArg = leftPad === 0 && rightPad === 0
                                ? argDocs[i]
                                : [" ".repeat(leftPad), argDocs[i], " ".repeat(rightPad)];
                            argParts.push(i % colCount === 0 ? hardline : " ");
                            argParts.push(alignedArg);
                            if (i !== argDocs.length - 1) {
                                argParts.push(",");
                            }
                        }
                    }
                }
                if (!argParts) {
                    argParts = [softline, join([",", line], argDocs)];
                }
                return group([
                    p("callee"),
                    "(",
                    indent(argParts),
                    softline,
                    ")",
                ]);
            }
            try {
                switch (n.kind) {
                    ////////// DECLARATIONS
                    case "translationUnit": {
                        const parts = [];
                        path.each((path, _index) => {
                            const value = path.getValue();
                            parts.push(print(path));
                            if (prettier.util.isNextLineEmpty(options.originalText, value, locEnd)) {
                                parts.push(hardline);
                            }
                            parts.push(hardline);
                        }, "declarations");
                        return parts;
                    }
                    case "precisionDeclaration":
                        return [
                            "precision ",
                            n.precisionQualifier.image,
                            " ",
                            path.call(print, "typeSpecifierNoPrec"),
                            ";",
                        ];
                    case "fullySpecifiedType": {
                        const parts = [];
                        if (n.typeQualifier) {
                            parts.push(p("typeQualifier"), " ");
                        }
                        parts.push(p("typeSpecifier"));
                        return parts;
                    }
                    case "typeSpecifier": {
                        const parts = [];
                        if (n.precisionQualifier) {
                            parts.push(n.precisionQualifier.image, " ");
                        }
                        parts.push(p("typeSpecifierNonArray"));
                        if (n.arraySpecifier) {
                            parts.push(p("arraySpecifier"));
                        }
                        return parts;
                    }
                    case "typeQualifier": {
                        const parts = [];
                        if (n.invariantQualifier) {
                            parts.push("invariant");
                        }
                        if (n.interpolationQualifier) {
                            parts.push(n.interpolationQualifier.image);
                        }
                        if (n.layoutQualifier) {
                            parts.push(p("layoutQualifier"));
                        }
                        if (n.storageQualifier) {
                            parts.push(p("storageQualifier"));
                        }
                        return join(" ", parts);
                    }
                    case "storageQualifier": {
                        const parts = [];
                        if (n.CONST) {
                            parts.push("const");
                        }
                        // SPEC: "A variable may be qualified as flat centroid, which will
                        // mean the same thing as qualifying it only as flat."
                        // Normalize to just flat.
                        if (n.CENTROID &&
                            path.getParentNode().interpolationQualifier
                                ?.tokenType !== TOKEN.FLAT) {
                            parts.push("centroid");
                        }
                        if (n.IN) {
                            parts.push("in");
                        }
                        if (n.OUT) {
                            parts.push("out");
                        }
                        if (n.VARYING) {
                            parts.push("varying");
                        }
                        if (n.ATTRIBUTE) {
                            parts.push("attribute");
                        }
                        if (n.UNIFORM) {
                            parts.push("uniform");
                        }
                        return join(" ", parts);
                    }
                    case "functionPrototype":
                    case "functionDefinition":
                        return [
                            group([
                                p("returnType"),
                                " ",
                                p("name"),
                                "(",
                                indent([
                                    softline,
                                    join([",", line], path.map(print, "params")),
                                ]),
                                softline,
                                ")",
                            ]),
                            n.kind === "functionPrototype" ? ";" : [" ", p("body")],
                        ];
                    case "parameterDeclaration":
                        return [
                            n.parameterTypeQualifier
                                ? [p("parameterTypeQualifier"), " "]
                                : "",
                            n.parameterQualifier?.tokenType === TOKEN.OUT ||
                                n.parameterQualifier?.tokenType === TOKEN.INOUT
                                ? n.parameterQualifier?.image + " "
                                : "",
                            p("typeSpecifier"),
                            " ",
                            p("pName"),
                            p("arraySpecifier"),
                        ];
                    case "initDeclaratorListDeclaration":
                    case "structDeclaration": {
                        const printed = path.map(print, "declarators");
                        const parentNode = path.getParentNode();
                        const isParentForLoop = parentNode.kind === "forStatement";
                        const hasInit = n.declarators.some((decl) => decl.init);
                        // If we have multiple declarations, or if the only declaration is
                        // on its own line due to a comment, indent the declarations.
                        // TODO: hasComment?
                        return group([
                            p("fsType"),
                            printed.length === 0 ? "" : " ",
                            printed.length === 1
                                ? printed
                                : group(indent(join([",", hasInit && !isParentForLoop ? hardline : line], printed))),
                            ";",
                        ]);
                    }
                    case "declarator": {
                        const arraySpecifier = p("arraySpecifier");
                        const leftDoc = [n.name.image, arraySpecifier];
                        return printAssignmentLike(path, options, leftDoc, " =", p("init"), n.init);
                    }
                    case "arraySpecifier":
                        return group([
                            "[",
                            indent([softline, p("size")]),
                            softline,
                            "]",
                        ]);
                    case "arrayAccess":
                        return [
                            paren(p("on"), getPrecedence(n.on, inMacro) > 2),
                            "[",
                            p("index"),
                            "]",
                        ];
                    case "structSpecifier": {
                        const parts = [];
                        path.each((path, index, declarations) => {
                            const value = path.getValue();
                            parts.push(hardline);
                            parts.push(print(path));
                            if (index !== declarations.length - 1 &&
                                prettier.util.isNextLineEmpty(options.originalText, value, locEnd)) {
                                parts.push(hardline);
                            }
                        }, "declarations");
                        return group([
                            "struct",
                            n.name ? " " + n.name.image : "",
                            " {",
                            indent(parts),
                            hardline,
                            "}",
                        ]);
                    }
                    ///////// STATEMENTS
                    case "compoundStatement": {
                        const parts = [];
                        const nodeHasComment = !!n.comments?.some((c) => !c.leading && !c.trailing && !c.printed);
                        path.each((path, index) => {
                            const value = path.getValue();
                            if (index !== 0) {
                                parts.push(hardline);
                            }
                            parts.push(print(path));
                            if (prettier.util.isNextLineEmpty(options.originalText, value, locEnd)) {
                                parts.push(hardline);
                            }
                        }, "statements");
                        // print dangling comments
                        if (nodeHasComment) {
                            path.each((path) => {
                                const comment = path.getValue();
                                if (!comment.leading && !comment.trailing) {
                                    parts.push(printComment(path, options));
                                    comment.printed = true;
                                }
                            }, "comments");
                        }
                        return group([
                            "{",
                            parts.length ? [indent([hardline, parts]), hardline] : "",
                            "}",
                        ]);
                    }
                    case "returnStatement": {
                        if (n.what) {
                            const what = p("what");
                            return ["return", " ", what, ";"];
                        }
                        else {
                            return "return;";
                        }
                        // return ["return", " ", conditionalGroup([what, indent(what)]), ";"]
                    }
                    case "breakStatement":
                        return "break;";
                    case "continueStatement":
                        return "continue;";
                    case "discardStatement":
                        return "discard;";
                    case "selectionStatement": {
                        const parts = [];
                        const yes = adjustClause(n.yes, p("yes"), false);
                        const opening = group([
                            "if (",
                            group([indent([softline, p("condition")]), softline]),
                            ")",
                            yes,
                        ]);
                        parts.push(opening);
                        if (n.no) {
                            const commentOnOwnLine = n.yes.comments?.some((c) => c.trailing && c.tokenType === TOKEN.LINE_COMMENT) ||
                                lodash.findLast(n.yes.comments, (c) => !c.leading && !c.trailing)
                                    ?.tokenType === TOKEN.LINE_COMMENT;
                            const elseOnSameLine = n.yes.kind === "compoundStatement" && !commentOnOwnLine;
                            parts.push(elseOnSameLine ? " " : hardline);
                            parts.push("else", group(adjustClause(n.no, p("no"), n.no.kind === "selectionStatement")));
                        }
                        return parts;
                    }
                    case "forStatement": {
                        const statement = adjustClause(n.statement, p("statement"), false);
                        // We want to keep dangling comments above the loop to stay consistent.
                        // Any comment positioned between the for statement and the parentheses
                        // is going to be printed before the statement.
                        // const dangling = printDanglingComments(
                        //   path,
                        //   options,
                        //   /* sameLine */ true,
                        // )
                        // TODO
                        const dangling = false;
                        const printedComments = dangling ? [dangling, softline] : "";
                        if (n.initExpression.kind === "expressionStatement" &&
                            !n.initExpression.expression &&
                            !n.conditionExpression &&
                            !n.loopExpression) {
                            return [printedComments, group(["for (;;)", statement])];
                        }
                        return [
                            printedComments,
                            group([
                                "for (",
                                group([
                                    indent([
                                        softline,
                                        p("initExpression"),
                                        line,
                                        p("conditionExpression"),
                                        ";",
                                        line,
                                        p("loopExpression"),
                                    ]),
                                    softline,
                                ]),
                                ")",
                                statement,
                            ]),
                        ];
                    }
                    case "whileStatement": {
                        const statement = adjustClause(n.statement, p("statement"), false);
                        return [
                            "while (",
                            group(p("conditionExpression")),
                            ")",
                            statement,
                        ];
                    }
                    case "doWhileStatement":
                        return [
                            "do ",
                            p("statement"),
                            " while (",
                            group(p("conditionExpression")),
                            ");",
                        ];
                    ////////// EXPRESSIONS
                    case "functionCall":
                        return printFunctionCall(n);
                    case "methodCall":
                        return [
                            paren(p("on"), getPrecedence(n.on, inMacro) > 2),
                            ".",
                            p("functionCall"),
                        ];
                    case "postfixExpression":
                        return [
                            paren(p("on"), getPrecedence(n.on, inMacro) > 2),
                            p("op"),
                        ];
                    case "unaryExpression":
                        return [
                            p("op"),
                            paren(p("on"), getPrecedence(n.on, inMacro) > 3),
                        ];
                    case "assignmentExpression": {
                        const leftDoc = p("lhs");
                        return printAssignmentLike(path, options, leftDoc, " " + n.op.image, p("rhs"), n.rhs);
                    }
                    case "conditionalExpression":
                        return [
                            paren(p("condition"), getPrecedence(n.condition, inMacro) >= 15),
                            indent([
                                line,
                                "? ",
                                p("yes"),
                                line,
                                ": ",
                                p("no"),
                            ]),
                        ];
                    case "commaExpression":
                    case "binaryExpression": {
                        const parts = printBinaryishExpressions(path, print, n, inMacro);
                        const parent = path.getParentNode();
                        const isInsideParenthesis = parent.kind === "selectionStatement" ||
                            parent.kind === "whileStatement" ||
                            parent.kind === "switchStatement" ||
                            parent.kind === "doWhileStatement";
                        // if (
                        //   this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
                        // ) {
                        //
                        // looks super weird, we want to break the children if the parent breaks
                        //
                        // if (
                        //   this.hasPlugin("dynamicImports") &&
                        //   this.lookahead().type === tt.parenLeft
                        // ) {
                        if (isInsideParenthesis) {
                            return parts;
                        }
                        const needsParen = () => {
                            const parent = path.getParentNode();
                            if (!parent) {
                                return false;
                            }
                            // Comma expressions passed as arguments need parentheses.
                            // E.g. foo((a, b), c)
                            if (parent.kind === "functionCall" &&
                                n.kind === "commaExpression") {
                                return true;
                            }
                            // Bitwise operators are wrapped in parentheses for clarity.
                            // E.g. a << (u & 16)
                            if (parent.kind === "binaryExpression" &&
                                isBitwiseOperator(parent.op.tokenType)) {
                                return true;
                            }
                            return false;
                        };
                        const parentParent = path.getParentNode(1);
                        // Avoid indenting sub-expressions in some cases where the first sub-expression is already
                        // indented accordingly. We should indent sub-expressions where the first case isn't indented.
                        const shouldNotIndent = parent.kind === "returnStatement" ||
                            parent.kind === "forStatement" ||
                            (parent.kind === "conditionalExpression" &&
                                parentParent.kind !== "returnStatement" &&
                                parentParent.kind !== "functionCall") ||
                            parent.kind === "assignmentExpression" ||
                            parent.kind === "declarator";
                        if (shouldNotIndent) {
                            return group(parts);
                        }
                        else {
                            // Separate the leftmost expression, possibly with its leading comments.
                            const headParts = parts.slice(0, 1);
                            const rest = parts.slice(headParts.length);
                            return group(paren([
                                // Don't include the initial expression in the indentation
                                // level. The first item is guaranteed to be the first
                                // left-most expression.
                                ...headParts,
                                indent(rest),
                            ], needsParen()));
                        }
                    }
                    case "expressionStatement":
                        return [p("expression"), ";"];
                    case "fieldAccess":
                        return [
                            paren(p("on"), getPrecedence(n.on, inMacro) > 2),
                            ".",
                            p("field"),
                        ];
                    case "constantExpression": {
                        const c = n.const_;
                        if (c.tokenType === TOKEN.FLOATCONSTANT) {
                            return normalizeFloat(c.image);
                        }
                        return c.image;
                    }
                    case "variableExpression":
                        return n.var.image;
                    case "ppDefine": {
                        options.inMacro = n.params;
                        const doc = group([
                            "#define",
                            " ",
                            p("what"),
                            n.params
                                ? ["(", join([", "], path.map(print, "params")), ")"]
                                : "",
                            indent([
                                line,
                                n.node
                                    ? paren(p("node"), isExpression(n.node))
                                    : fill(join(line, path.map(print, "tokens")).parts),
                            ]),
                        ]);
                        options.inMacro = undefined;
                        return formatMacroDefinition(doc, options);
                    }
                    case "ppDir": {
                        return formatMacroDefinition(group([
                            "#",
                            n.dir.image,
                            " ",
                            indent(n.node
                                ? p("node")
                                : fill(join(line, path.map(print, "tokens")).parts)),
                        ]), options);
                    }
                    case "ppPragma":
                        return n.dir.image
                            .replace(/^#\s+/, "#")
                            .replace(/^#pragma\s{2,}/, "#pragma ");
                    case "ppCall": {
                        return group([
                            n.callee.image,
                            "(",
                            join([",", line], path.map((path, index, value) => {
                                return value[index].tokens.map((t) => t.image);
                            }, "args")),
                            ")",
                        ]);
                    }
                    case "ppInclude":
                        return ["#include ", n.what.image];
                    case "switchStatement": {
                        return [
                            "switch (",
                            group([
                                indent([softline, p("initExpression")]),
                                softline,
                            ]),
                            ") {",
                            n.cases.length
                                ? indent([hardline, join(hardline, path.map(print, "cases"))])
                                : "",
                            hardline,
                            "}",
                        ];
                    }
                    case "caseBlock": {
                        const caseLabel = p("caseLabel");
                        const parts = [];
                        path.each((path, index) => {
                            const value = path.getValue();
                            parts.push(hardline);
                            parts.push(print(path));
                            if (prettier.util.isNextLineEmpty(options.originalText, value, locEnd)) {
                                parts.push(hardline);
                            }
                        }, "statements");
                        return [caseLabel, indent(parts)];
                    }
                    case "caseLabel": {
                        return n.case_ === undefined
                            ? "default:"
                            : ["case ", p("case_"), ":"];
                    }
                    case "layoutQualifier":
                        return [
                            "layout(",
                            join(", ", n.layoutQualifierIds.map((lqi) => {
                                return lqi.init === undefined
                                    ? lqi.IDENTIFIER.image
                                    : [lqi.IDENTIFIER.image, " = ", lqi.init.image];
                            })),
                            ")",
                        ];
                    case "uniformBlock":
                        return [
                            p("typeQualifier"),
                            " ",
                            n.blockName.image,
                            " {",
                            indent([
                                hardline,
                                join(hardline, path.map(print, "declarations")),
                            ]),
                            hardline,
                            "};",
                        ];
                    case "typeQualifierDeclaration":
                        return [p("typeQualifier"), ";"];
                    default:
                        throw new Error("unexpected n type " +
                            n.kind +
                            "\n" +
                            JSON.stringify(n).substring(0, 100));
                }
            }
            catch (e) {
                console.error("error printing " + JSON.stringify(n).substring(0, 100) + "\n");
                throw e;
            }
        },
        // @ts-expect-error getCommentChildNodes isn't in the API for some reason
        getCommentChildNodes(node) {
            return isToken(node) ? [] : CHILDREN_VISITOR.visit(node);
        },
        canAttachComment(_node) {
            return true;
        },
        printComment,
        hasPrettierIgnore(path) {
            const value = path.getValue();
            return ((value &&
                isNode(value) &&
                value.comments?.some((c) => /\/\/\s*prettier-ignore\b.*/.test(c.image))) ??
                false);
        },
    },
};
function printComment(
// Path to the current comment node
commentPath, 
// Current options
options) {
    const n = commentPath.getValue();
    if (n.tokenType === TOKEN.MULTILINE_COMMENT && n.image[2] === "*") {
        const src = n.image
            .substring(3, n.image.length - 2)
            .split("\n")
            .map((l) => l === " *" ? "" : l.startsWith(" * ") ? l.substring(3) : l)
            .join("\n")
            .trim();
        const formattedComment = prettier.format(src, {
            ...options,
            printWidth: options.printWidth - 3,
            parser: "markdown",
            proseWrap: "always",
            plugins: [],
        });
        const formattedCommentLines = formattedComment.split("\n");
        // Remove the final newline which markdown formatter always adds.
        formattedCommentLines.pop();
        return ("/**\n" +
            formattedCommentLines
                .map((l) => (l === "" ? " *" : " * " + l))
                .join("\n") +
            "\n */");
    }
    return n.image;
}

exports.CHILDREN_VISITOR = CHILDREN_VISITOR;
exports.languages = languages;
exports.parsers = parsers;
exports.printers = printers;
//# sourceMappingURL=prettier-plugin.cjs.js.map
